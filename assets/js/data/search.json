[ { "title": "AzureStack HCI的成本精算", "url": "/Cheapest_HCI/", "categories": "Azure Stack HCI, 规划", "tags": "Azure, Stack, HCI", "date": "2022-08-24 00:00:00 +0800", "snippet": "不是一个人，而是很多朋友在了解HCI产品后，会觉得AzureStack HCI的价格很高，难落地。有时候感觉是不太准的，所以我们来详细818 Azure Stack HCI的计费方式，以及这个东西的影响。为了详细的分析，这个事情要分两个方面讨论 跟谁比 怎么用通过计算，我也希望找到触碰到Azure Statck HCI 底线的配置。底线顾名思义，就是到头了，不能再省钱了，再省钱就影响功能了。Azure Stack HCI的计费方式超融合基础架构（Hyper-converged infrastructure，缩写为HCI）是SDX（软件定义一切）时期的附加产物，其特点是计算、存储、网络的提供能力是等比、线性提升的，什么意思？拿挖矿来类比，就是1个节点算力为1，两个节点就是2，没有损耗。简单并且易于使用。用户可以根据实际需求，往群集增加节点，来实现整体群集运算能力的提升。所以它背后隐藏了一些高级功能的说明，比如分布式存储、网络虚拟化、计算虚拟化、管理平台，当然还有针对本身平台的高可用属性。所以HCI是一种一揽子工程，是一种相对高级的实现方式，是对纯虚拟化产品的一种升级。Azure Stack HCI的计费方式简单粗暴，按照用量计费。 从Azure账户中合并计费 每个物理主机按照1核心10美元收取月租 除了这个费用，再没有其他的了。和传统虚拟化一哥VMWare的针对虚拟化和VSAN单独计费、并且有最低16物理核低消相比，灵活性和价格都是占优的。以一台 机器两颗16核的Intel® Xeon® Gold 6326 )， 汇率6.86来算，一年的许可证费用无折扣是16*2*6.86*10*12=26343，这个价格不过不失，属于正常授权的价格，如果公司有Azure的折扣，那么这个折扣也可以映射到这里。选什么CPU？Intel的CPU细节我们可以参考 Intel Ark 。选择CPU其实很简单，注意几个指标就可以了： 发布时间：俗话说买新不买旧 功耗：同技术代差，理论上功耗越高性能越好。毕竟服务器不图省电 价格：这个没什么可说的，量力而行。 核心数：至少8核（后面会解释为什么）有的朋友说，我想AMD yes行不行？只能说一半一半，CPU的选型远不止总算力这么简单。比如AMD官网宣传的产品对比，AMD用多出的24个核心，跑出来比Intel更好的成绩，并且提供了更低的价格（接近3000美元）。但是依然要说，单核性能上，Intel还是大哥。 CPU 价格 核心 AMD EPYC 7763 $5,599.00 USD (2022-08-23) 64C Intel® Xeon® Platinum 8380 $8,978.00 USD (2022-04-03) 40C 回到授权（正版授权）上，无论微软还是VMWare，都是以CPU核心数来授权，因此AMD的这种架构就比较吃亏了。以那多出来的24个核心来计，每年正版授权支出需要多24*2*10*12=5760美元，买CPU省下来的钱一年就干秃噜了。单纯的分布式存储架构HCI既然是软件定义的计算，软件定义的存储，软件定义的网络，那这些东西能不能拆开用呢？答案是肯定的。 那就是用HCI做超融合存储。是的，就是单纯的存储，不使用网络虚拟化功能。因为HCI有完整的Iscsi和SOFS功能，且可以在群集模式下提供服务，并且不限定存储的连接放。作为传统企业，这其实也有比较大的应用市场。那么它的直接对手，就是VSAN这里为了最大化成本优势，需要依据授权方式，计算最合理的CPU选型。对于HCI的CPU选型，其实有一个最低的底线，那就是CPU性能至少要保证分布式存储S2D能够正常工作。那怎么算正常工作呢，首先需要保证网卡的对内对外通信没有问题。为了降低网络对CPU的影响，出现了一种网卡专有技术，叫做RDMA，我们不去细聊RDMA是什么，只需要知道，买的网卡上有这项功能，那么同样支持RDMA的网卡之间通信，就可以享受到低延迟，低CPU占用的特性。HCI的部署，一般我们推荐使用iwarp,这单纯就是因为省事儿，部署简单。ROCE需要更多经验丰富的人去配置，以及需要底层硬件的支持，所以并不适合中小规模的部署。作为两种芯片都生产的Marvell，它发布了两者的对比差异。相对来说，观点比较中立，可供阅读。RoCE 或 iWARP 的低延迟？- Marvell博客问题来了，既然RDMA可以极大降低CPU的利用率，那CPU岂不是随便买都都可以？这个时候要注意了，RDMA只会对同样开启RDMA的对端设备生效，也就是RDMA只是在自己的范围内生效，在HCI的场景中，就是HCI内部的分布式存储S2D通信，才会用到RDMA，如果和HCI以外的机器通信，就回到传统网络中来，没有RDMA可用了。虽然Intel最低端的CPU是 Intel® Xeon® Silver 4112 Processor )，但作为HCI的CPU选型，我们无论如何是不能选它的。它仅仅只有4个核心，连10G的带宽都跑不满（ 【网络实验】10G网络下的真实带宽——CPU负载与网卡TSO、GSO）。单个CPU核心只能支撑接近2.5G的网卡流量，分配5个核心才可以跑满10G。这种配置下，选配一个高主频，核心少的CPU才能满足接近20G的流量需求。20G这个标准怎么来的？这是因为多数情况，我们都会至少购买一张双网口，单口10G的卡。如果卡的规格提升，那么CPU的规格也要同比提升。所以说，8核是Azure Stack HCI的底线，一台主机不能少于8核，要不就会极大影响性能的发挥了。至于选什么，还是依照上面给出的建议，选择价格合适，主频够高的产品。分布式存储的整个群集计费单纯以分布式存储而言，AzureStack HCI拥有无与伦比的价格优势。以一个群集3个节点，每个节点配备一颗8核的CPU来计算，一年只需要 8*3*6.86*10*12=19,756，还没有突破2万大关。这个价格对企业级的商业分布式存储用户而言，不能说贵到天际，只能说是基本白送。超融合架构如果需要很好的利用超融合架构的计算功能，那么除了每个节点预留8核之外，其他的资源都可以用来做计算能力的输出。这种计费没有低消，也只需要根据用量付费，销毁主机后即停止计费。VMWare收费方式了解一下友商的定价方式，就知道Azure Stack HCI处于什么级别。VMware购买订阅网卡选择知乎有一位朋友分享了现在主流网卡对RDMA的支持，方便大家了解和选购。19. RDMA之iWARP &amp; Soft-iWARP - 知乎 (zhihu.com)网卡的选择只是一个简单的二选一，iwarp或者ROCE。 这些驱动程序所属的厂家（括号外的公司被括号内的公司收购或者为其子公司）如下： 驱动名 厂商 Infiniband RoCE v2 iWARP 备注 bnxt_re Broadcom   √     cxgb4 Chelsio     √   efa Amazon       自成一派，使用自研的SRD协议，也支持UD。 hfi1 Cornelis       使用Omni-Path协议，从Intel拆分出来的公司。 hns HiSilicon(Huawei)   √     irdma Intel   √ √   mlx4 Mellanox(NVIDIA) √ √     mlx5 Mellanox(NVIDIA) √ √     mthca Mellanox(NVIDIA) √       ocrdma Emulex(Broadcom)       只支持RoCEv1，很久没更新了。 qedr QLogic(Marvell)   √ √ Qlogic非IB部分最终被Marvell收购 qib Qlogic(Intel) √     Qlogic的IB技术被Intel收购 usnic Cisio       私有协议 vmw_pvrdma VMware   √     Azure Stack HCI支持功能列表HCI的的支持特性如下所示，列出来的功能都是允许在HCI系统中安装和使用的。比如我们给节点安装SOFS和ISCSI功能，只需要行命令即可。icm 节点名称{Install-WindowsFeature FS-FileServer -IncludeAllSubFeature -IncludeManagementTools}icm 节点名称{Install-WindowsFeature FS-iSCSITarget-Server -IncludeAllSubFeature -IncludeManagementTools}Display Name Name Install State------------ ---- -------------[X] Hyper-V Hyper-V Installed[ ] Web 服务器(IIS) Web-Server Available [ ] Web 服务器 Web-WebServer Available [ ] 安全性 Web-Security Available [ ] 请求筛选 Web-Filtering Available [ ] IIS 客户端证书映射身份验证 Web-Cert-Auth Available [ ] IP 和域限制 Web-IP-Security Available [ ] URL 授权 Web-Url-Auth Available [ ] Windows 身份验证 Web-Windows-Auth Available [ ] 基本身份验证 Web-Basic-Auth Available [ ] 集中式 SSL 证书支持 Web-CertProvider Available [ ] 客户端证书映射身份验证 Web-Client-Auth Available [ ] 摘要式身份验证 Web-Digest-Auth Available [ ] 常见 HTTP 功能 Web-Common-Http Available [ ] HTTP 错误 Web-Http-Errors Available [ ] 静态内容 Web-Static-Content Available [ ] 默认文档 Web-Default-Doc Available [ ] 目录浏览 Web-Dir-Browsing Available [ ] HTTP 重定向 Web-Http-Redirect Available [ ] WebDAV 发布 Web-DAV-Publishing Available [ ] 性能 Web-Performance Available [ ] 静态内容压缩 Web-Stat-Compression Available [ ] 动态内容压缩 Web-Dyn-Compression Available [ ] 运行状况和诊断 Web-Health Available [ ] HTTP 日志记录 Web-Http-Logging Available [ ] ODBC 日志记录 Web-ODBC-Logging Available [ ] 跟踪 Web-Http-Tracing Available [ ] 请求监视器 Web-Request-Monitor Available [ ] 日志记录工具 Web-Log-Libraries Available [ ] 自定义日志 Web-Custom-Logging Available [ ] 应用程序开发 Web-App-Dev Available [ ] .NET Extensibility 3.5 Web-Net-Ext Available [ ] .NET Extensibility 4.8 Web-Net-Ext45 Available [ ] ASP Web-ASP Available [ ] ASP.NET 3.5 Web-Asp-Net Available [ ] ASP.NET 4.8 Web-Asp-Net45 Available [ ] CGI Web-CGI Available [ ] ISAPI 扩展 Web-ISAPI-Ext Available [ ] ISAPI 筛选器 Web-ISAPI-Filter Available [ ] WebSocket 协议 Web-WebSockets Available [ ] 服务器端包含 Web-Includes Available [ ] 应用程序初始化 Web-AppInit Available [ ] FTP 服务器 Web-Ftp-Server Available [ ] FTP 服务 Web-Ftp-Service Available [ ] FTP 扩展 Web-Ftp-Ext Available [ ] 管理工具 Web-Mgmt-Tools Available [ ] IIS 管理控制台 Web-Mgmt-Console Available [ ] IIS 6 管理兼容性 Web-Mgmt-Compat Available [ ] IIS 6 元数据库兼容性 Web-Metabase Available [ ] IIS 6 WMI 兼容性 Web-WMI Available [ ] IIS 6 脚本工具 Web-Lgcy-Scripting Available [ ] IIS 管理脚本和工具 Web-Scripting-Tools Available [ ] 管理服务 Web-Mgmt-Service Available[ ] 网络控制器 NetworkController Available[X] 文件和存储服务 FileAndStorage-Services Installed [X] 存储服务 Storage-Services Installed [ ] 文件和 iSCSI 服务 File-Services Available [ ] 文件服务器 FS-FileServer Available [ ] DFS 复制 FS-DFS-Replication Available [ ] DFS 命名空间 FS-DFS-Namespace Available [ ] iSCSI 目标存储提供程序(VDS 和 VSS 硬件提... iSCSITarget-VSS-VDS Available [ ] iSCSI 目标服务器 FS-iSCSITarget-Server Available [ ] NFS 服务器 FS-NFS-Service Available [ ] 工作文件夹 FS-SyncShareService Available [ ] 网络文件 BranchCache FS-BranchCache Available [ ] 文件服务器 VSS 代理服务 FS-VSS-Agent Available [ ] 文件服务器资源管理器 FS-Resource-Manager Available [ ] 重复数据删除 FS-Data-Deduplication Available[ ] 远程访问 RemoteAccess Available [ ] DirectAccess 和 VPN (RAS) DirectAccess-VPN Available [ ] Web 应用程序代理 Web-Application-Proxy Available [ ] 路由 Routing Available[ ] .NET Framework 3.5 功能 NET-Framework-Features Available [ ] .NET Framework 3.5 (包括 .NET 2.0 和 3.0) NET-Framework-Core Removed [ ] HTTP 激活 NET-HTTP-Activation Available [ ] 非 HTTP 激活 NET-Non-HTTP-Activ Available[X] .NET Framework 4.8 Features NET-Framework-45-Fea... Installed [X] .NET Framework 4.8 NET-Framework-45-Core Installed [ ] ASP.NET 4.8 NET-Framework-45-ASPNET Available [X] WCF 服务 NET-WCF-Services45 Installed [ ] HTTP 激活 NET-WCF-HTTP-Activat... Available [X] TCP 端口共享 NET-WCF-TCP-PortShar... Installed [ ] TCP 激活 NET-WCF-TCP-Activati... Available [ ] 命名管道激活 NET-WCF-Pipe-Activat... Available [ ] 消息队列(MSMQ)激活 NET-WCF-MSMQ-Activat... Available[ ] BitLocker 驱动器加密 BitLocker Available[ ] Enhanced Storage EnhancedStorage Available[ ] I/O 服务质量 DiskIo-QoS Available[ ] IIS 可承载 Web 核心 Web-WHC Available[ ] IP 地址管理(IPAM)服务器 IPAM Available[X] Microsoft Defender 防病毒 Windows-Defender Installed[ ] Network ATC NetworkATC Available[ ] NFS 客户端 NFS-Client Available[ ] SMB 1.0/CIFS 文件共享支持 FS-SMB1 Available [ ] SMB 1.0/CIFS 服务器 FS-SMB1-SERVER Available [ ] SMB 1.0/CIFS 客户端 FS-SMB1-CLIENT Available[ ] SMB 带宽限制 FS-SMBBW Available[ ] SNMP 服务 SNMP-Service Available [ ] SNMP WMI 提供程序 SNMP-WMI-Provider Available[X] Windows PowerShell PowerShellRoot Installed [X] Windows PowerShell 5.1 PowerShell Installed [ ] Windows PowerShell 2.0 Engine PowerShell-V2 Removed [ ] Windows PowerShell Desired State Configurati... DSC-Service Available [ ] Windows PowerShell Web 访问 WindowsPowerShellWeb... Available[ ] Windows Process Activation Service WAS Available [ ] 进程模型 WAS-Process-Model Available [ ] .NET Environment 3.5 WAS-NET-Environment Available [ ] 配置 API WAS-Config-APIs Available[ ] Windows Server Migration Tools Migration Available[ ] Windows Server 备份 Windows-Server-Backup Available[ ] Windows Subsystem for Linux Microsoft-Windows-Su... Available[ ] Windows 内部数据库 Windows-Internal-Dat... Available[ ] WinRM IIS 扩展 WinRM-IIS-Ext Available[X] WoW64 支持 WoW64-Support Installed[ ] 存储副本 Storage-Replica Available[ ] 存储迁移服务 SMS Available[ ] 存储迁移服务代理 SMS-Proxy Available[ ] 多路径 I/O Multipath-IO Available[X] 故障转移群集 Failover-Clustering Installed[ ] 管理 OData IIS 扩展 ManagementOdata Available[ ] 后台智能传输服务(BITS) BITS Available [ ] IIS 服务器扩展 BITS-IIS-Ext Available [ ] Compact 服务器 BITS-Compact-Server Available[ ] 基于 Windows 标准的存储管理 WindowsStorageManage... Available[ ] 简单 TCP/IP 服务 Simple-TCPIP Available[ ] 容器 Containers Available[ ] 软件负载平衡器 SoftwareLoadBalancer Available[ ] 数据中心桥接 Data-Center-Bridging Available[ ] 网络虚拟化 NetworkVirtualization Available[ ] 无线 LAN 服务 Wireless-Networking Available[X] 系统见解 System-Insights Installed[X] 系统数据存档工具 System-DataArchiver Installed[ ] 消息队列 MSMQ Available [ ] 消息队列服务 MSMQ-Services Available [ ] 消息队列服务器 MSMQ-Server Available [ ] HTTP 支持 MSMQ-HTTP-Support Available [ ] 路由服务 MSMQ-Routing Available [ ] 目录服务集成 MSMQ-Directory Available [ ] 消息队列触发器 MSMQ-Triggers Available [ ] 消息队列 DCOM 代理 MSMQ-DCOM Available[ ] 用于结构管理的 VM 防护工具 FabricShieldedTools Available[ ] 远程差分压缩 RDC Available[X] 远程服务器管理工具 RSAT Installed [X] 功能管理工具 RSAT-Feature-Tools Installed [ ] BitLocker 驱动器加密管理实用程序 RSAT-Feature-Tools-B... Available [ ] DataCenterBridging LLDP Tools RSAT-DataCenterBridg... Available [ ] IP 地址管理(IPAM)客户端 IPAM-Client-Feature Available [ ] PowerShell module for Azure Stack HCI RSAT-Azure-Stack-HCI Available [ ] 存储迁移服务工具 RSAT-SMS Available [X] 故障转移群集工具 RSAT-Clustering Installed [X] Windows PowerShell 的故障转移群集模块 RSAT-Clustering-Powe... Installed [ ] 故障转移群集命令接口 RSAT-Clustering-CmdI... Available [ ] 故障转移群集自动化服务器 RSAT-Clustering-Auto... Available [X] 适用于 Windows PowerShell 的系统见解模块 RSAT-System-Insights Installed [ ] 受防护的 VM 工具 RSAT-Shielded-VM-Tools Available [ ] 用于 Windows PowerShell 的存储副本模块 RSAT-Storage-Replica Available [X] 角色管理工具 RSAT-Role-Tools Installed [ ] AD DS 和 AD LDS 工具 RSAT-AD-Tools Available [ ] AD DS 工具 RSAT-ADDS Available [ ] Active Directory 管理中心 RSAT-AD-AdminCenter Available [ ] AD DS 管理单元和命令行工具 RSAT-ADDS-Tools Available [ ] AD LDS 管理单元和命令行工具 RSAT-ADLDS Available [ ] Windows PowerShell 的 Active Directo... RSAT-AD-PowerShell Available [X] Hyper-V 管理工具 RSAT-Hyper-V-Tools Installed [X] Windows PowerShell 的 Hyper-V 模块 Hyper-V-PowerShell Installed [ ] Windows Server Update Services 工具 UpdateServices-RSAT Available [ ] API 和 PowerShell cmdlet UpdateServices-API Available [ ] DHCP 服务器工具 RSAT-DHCP Available [ ] DNS 服务器工具 RSAT-DNS-Server Available [ ] 网络控制器管理工具 RSAT-NetworkController Available [ ] 远程访问管理工具 RSAT-RemoteAccess Available [ ] 用于 Windows PowerShell 的远程访问模块 RSAT-RemoteAccess-Po... Available[ ] 主机保护者 Hyper-V 支持 HostGuardian Available[ ] 组策略管理 GPMC Available" }, { "title": "Jekyll模板升级笔记", "url": "/JekyllfastStart/", "categories": "Jekyll, 初级知识", "tags": "Jekyll", "date": "2022-08-19 00:00:00 +0800", "snippet": "Jekyll 是什么我的博客是托管在Github Pages上的，使用了一种叫做Jekyll的技术构建。最近由于系统邮件一直告诉我有安全漏洞，需要升级，所以我到处找合适的升级模板。个人理解，Jekyll 基于Ruby开发的，一种和Github Pages 组合使用的代码生成器。能够将markdown格式的文档，生成为html的静态网页。它的特性或者说是适用场景是明确的： MarkDown格式作为输入，最终转换成HTML 部署在Github Pages 不支持动态技术（ASP/PHP）安装Jekyll为了能够升级和调试现有的Jekyll，需要在本地部署它的构造环境。这个事情只需要做一次，所以可以在虚拟机中进行。由于我已经部署过kukisama.github.io这个库，也配置过自定义域名这些，对在Github中的操作不做过多叙述。另外我是在Windows下安装Jekyll，所以首先要前往https://jekyllrb.com/docs/installation/windows/查看说明，这里有详细的安装步骤。整个安装步骤比较简单。1、从RubyInstaller Downloads下载并安装Ruby+Devkit版本。使用默认选项进行安装。2、 安装结束后会有一个弹窗，3选1，我们选择MSYS2 and MINGW development tool chain。如果不小心关掉了，可以在cmd里面运行ridk install 重新把这个向导拉起来3、 再执行一下gem install jekyll bundler，这是核心步骤4、 最后执行jekyll -v，看是否成功安装配置安装Jekyll完成环境安装之后，接下来要开始做基础配置。操作都在PowerShell下执行，一行一行做，相对比较简单。下面的流程说明是针对一个一穷二白的空Jekyll而言的。#首先创建一个c:\\work的目录，然后前往这个目录。cd c:\\work#用jekyll初始化博客站点kukisama.github.io，在做这个操作之前，要提前用VScode将整个kukisama.github.io拉回来，也就是说，kukisama.github.io目录是实际存在的。jekyll new kukisama.github.io#前往这个目录cd kukisama.github.io#将这个目录变成可用的http站点，直接访问下面的地址即可看到实际效果#http://localhost:4000bundle exec jekyll serve# 如果系统是Ruby 3.0.0，且发现服务器起不来，输入这条命令# bundle 本身会在各种回显上进行提示，如果有报错，注意看下错误信息中关于bundle 的内容，按照提示可以修复错误。bundle add webrick#因为本身Jekyll是个代码生成器，修改MD并不是立刻映射到html文件上。#可以用这条命令启动服务，这样文件被改变之后，会即刻刷新网页bundle exec jekyll serve --livereload可以用下面这个链接，进行测试http://localhost:4000链接地址是本地的虚拟的服务器地址，端口固定。## 套用chirpy模板和Wordpress类似，要想输出好看，自己又不会写代码，就需要自己找个模板套上去。之前用的模板是https://github.com/onevcat/vno-jekyll的模板，大概是这个样子的。问题在于这个版本已经很久不更新了，然后Github报告站点用的模块有漏洞，必须要升级修复。因为没有新版本，所以只能更换。戏剧性的是，Vno-jekyll的作者自己也不用这个模板了，他用了 Chirpy 作为主题，感觉两个主题差不多，而且我不太想在这个事情上花太多功夫，我就也准备用 Chirpy这次犯了经验主义错误，我首先去Github找Chirpy的项目 https://github.com/cotes2020/jekyll-theme-chirpy ，然后按照以前使用Vno-jekyll的惯例，直接把整个站点代码克隆下来，放到自己的本地Jekyll目录中了，然后上传，等待同步。很显然这么搞失败了，而且在问题列表中看到，也有人和我出现一样的错误。花了一天半也没有搞定.没办法只能回来认真看文档，第一步就发现不一样了。我所在的项目叫jekyll-theme-chirpy，但是它需要克隆的代码库叫做Chirpy Starter ……按照提示，创建这个特定的存储库，然后看到有这么一句，我来到演示网站，这会才真的算是找对了方向。也就是说，它的真正的部署手册是https://chirpy.cotes.page/posts/getting-started/ 更多使用方法请参考演示网站/ wiki上的教程另外 https://github.com/cotes2020/jekyll-theme-chirpy/tree/master/_posts 这里有这个模板适用的相关语法可供查询，对应的前端页是https://chirpy.cotes.page/梳理模板部署过程根据官方文档和实践，整理一下这个测试确认好使的部署过程： 首先用Chirpy Starter 创建特定存储库 用VSCODE把代码拉回来 提前配置安装Jekyll环境 前往克隆回来的本地代码库目录 执行bundle 安装依赖 修改代码库目录中 _config.yml文件中 url部分，改成自己的xxx.github.io _config.yml有很多自定义选项，都不是太复杂，根据例子自行修改就可以了 不同模板的_config.yml都不一样，大家的定义不一样，不能想当然的照抄，只能看模板作者的例子。 因为我的电脑是windows，所以要运行一次 bundle lock --add-platform x86_64-linux 虽然我的站点有自定义域名，但是注意以前的配置方式（配置CNAME文件）已经失效了，在_config.yml文件中只需要定义xx.github.io 确保站点有 .github/workflows/pages-deploy.yml这个文件。 其值on.push.branches应与您的 repo 的默认分支名称相同 由于以前的master这个分支名被改成了比较中性的main，新弄的库都是main，老一点的是master，这里如果不一样，会导致Github Action无法触发。只能说大家都是受害者。 任意做一个修改,比如在POST目录提交一个文档，然后用VScode提交一次合并，会自动触发Github Action自动化的执行一些作业。 这个时候，打开在 GitHub 上的存储库。选择选项卡Settings，然后单击左侧导航栏中的Pages，然后在*GitHub Pages的源中，选择gh-pages的目录作为发布源。离开前记得点击。/(root)gh-pagesSave。 之前用的Vno-jekyll有很多年了，也可能是这两年的架构演进。chirpy的逻辑是主线发布不做任何修改，实际会生成站点目录结构的html文件到gh-pages分支上。至少以前是没有这种自动创建新分支并发布的逻辑的。 不太懂html，但是觉得这种逻辑生成的html，由于不需要做任何运算，单纯展示，连地址栏都不需要做转换，应该速度会比动态生成的快一些。 对比代码差异事实上我对于只能用 chirpy-starter-main部署，而不能用jekyll-theme-chirpy-master部署比较好奇，这两者的差异应该怎么分辨呢？可以使用Beyond Compare 4来进行文件对比，当然其他任何能够做对比的软件都可以。经过对比之后，发现两边的文件不能说是一模一样，只能说是差之千里。比如上面文档中提到的.github/workflows/pages-deploy.yml这个文件。chirpy-starter-main用的分支是main，而jekyll-theme-chirpy-master用的是master，这个可能是关键差异，除此之外的差异还包括jekyll-theme-chirpy-master使用了更多的插件，直接套用也可能有兼容性问题，由于我对html所知甚少，所以也就不再深挖。Github Action 问题处理在部署过程中，通过给POST目录上传markdown文档，我发现偶尔会部署失败。通过检查检查Action的部署过程，发现这是个不错的排错的窗口。例如发现Deploy有错误，展开之后可以看到，错误提示是 Html-proofer found 1failure。通过仔细看代码，发现是超链接前面多了一个#，在Markdown中，这个错误并不致命，也不影响显示，但是在代码生成过程中就出错了。解决方法就是回去修改POST目录下的实际文件，修改好后VScode重新提交更改。等待刷新。Jekyll 主题以下是一些主题站 jekyllthemes.org http://jekyllthemes.org/ jekyllthemes.io https://jekyllthemes.io/ jekyll-themes.com https://jekyll-themes.com/ Start Bootstrap https://startbootstrap.com/ Github https://github.com/topics/jekyll-theme jekyll-TeXt-theme https://github.com/kitian616/jekyll-TeXt-theme推荐最后一个， TeXt Theme 它最大最大的好处是，中文！" }, { "title": "WireShark快速多端点数据捕获", "url": "/WireSharkFastStart/", "categories": "", "tags": "WireShark", "date": "2022-08-17 00:00:00 +0800", "snippet": "需求一般来说，用命令行抓包是因为有以下需求 有很多机器需要同一个时间点抓包 频繁登录到不同主机去启动WireShark比较麻烦 将抓好的数据包拷贝到公共路径还需要花时间，还比如打包之类，这种操作很繁琐。所以如果只有1、2台机器需要抓包，简单的图形化工具也可以完成。也就没必要了解命令行下的操作。当然还有另外一个场景： 张三告诉李四，需要李四去抓包 李四不会 张三写脚本，方便李四的部署实施。 李四跑脚本获取，以及随身携带WirekShark是免费软件，主要用来抓数据包，然后分析网络数据包。官方提供了非安装的版本，直接下载Portable版本即可。和安装版相比，两者只是在内容组织上有所差异，实际没有没有任何差异。WireShark命令行工具实际上WireShark的纯命令行工具是TShark，这个是dumpcap的外壳程序。虽然WireSharek有命令行参数，但那仅仅是辅助打开GUI的一种方式，不是我们理解的，常规意义的命令行工具。 Wireshark 网络协议分析器提供了三种抓包的基本方法：GUI、Tshark 和 Dumpcap。GUI 是网络分析人员最常用的技术，但是那些想要从脚本中捕获或根本不想通过 GUI 工作的人使用 Tshark 或 Dumpcap。远程工具TShark不能远程执行（仅仅是有警告，不确定是否真的有问题），所以这里要借助到一个叫做PSEXEC的免费小工具，用来远程去加载。它属于Sysinternals的套件中的一个小程序。其功能是将不能通过PowerShell的PSSession来执行的程序完美执行。比如打补丁工具wsua需要注意，PSEXEC可以执行远程的应用程序，但是不能套娃PowerShell本身，所以我们需要构造PS1文件，然后使用Start-Process弹窗执行它，而PS1文件中包含PSEXEC的执行逻辑。这样解决了两个问题 Tshark不能远程执行 PSEXEC不能执行PowerShell准备安装完成WireShark之后，我们只需要取得当前目录的所有DLL以及/tshark.exe和/dumpcap.exe即可正常工作。所以在企业内部抓包的话，可以改造一下TShark的目录，文件少一点，拷贝也会快一些。如果是随身版的话，需要前往WiresharkPortable64_3.6.7.paf\\App\\Wireshark找到对应文件。经过处理过后的文件，只会找到\\device\\设备，其他虚拟设备是不会发现的，后面处理也相对省事一些需要注意的地方如果希望WireShark正常工作，还需要单独下载一个叫做Npcap 1.70 installer的东西。这个软件有一个特点就是公众版不允许静默安装。静默安装是收费版的权利。。。。。所以静默安装Npcap不讨论，假设我们需要在每个需要捕获数据包的节点上手动提前安装完成。正常工作的WireShark大概是这样的。捕获逻辑回忆一下我们抓包的过程 登录特定主机 安装Npcap 安装/拷贝WireShark 打开WireShark 选中需要抓包的网卡，一般全部选中 点击鲨鱼鳍标志，开始捕获 等待捕获结束，点红色方框结束 保存捕获文件 拷贝所有的捕获文件，然后放到一个集中的地方去分析 命令行完成的主要是选择网卡和捕获的过程，首先输入下面的指令，确认有哪些设备可以被捕获tshark.exe -D从图中可以知道，包含\\Device的设备是允许捕获的，也就是1-9。这个列表根据当前主机的信息不同，返回也不一样实际开始捕获的命令大致是这样的tshark.exe -a duration:20 -w c:\\abc.pcapng -i1 -i2 -i3 -i4 -i5 duration：持续捕获的时间，以秒计算 -w：数据包文件保存的位置 -i1 -i2：需要捕获的网卡接口。如果有多个网卡接口，需要依次输入。代码知道原理之后，就很容易写出实现部分，除了第一个安装Npcap由于本身的限制无法自动完成外，其他都可以脚本来实现。 安装Npcap 人工 安装/拷贝WireShark 脚本 打开WireShark 脚本 选中需要抓包的网卡，一般全部选中 脚本 点击鲨鱼鳍标志，开始捕获 脚本 等待捕获结束，点红色方框结束 脚本 保存捕获文件 脚本 拷贝所有的捕获文件，然后放到一个集中的地方去分析 脚本#初始化一些变量，本地文件路径，主机列表，预期的远程路径，捕获的数据包持续的时间（秒）$WireSharkPath = \"c:\\t\"$TargetHost = \"localhost\", \"LAB-DC01\"$TargetPath = \"c:\\test\"$Seconds = 10#拷贝文件$convertTargetHost = $TargetHost | ForEach-Object { \"\\\\\" + \"$_\" + \"\\\" }$convertTargetHost | ForEach-Object { $convertTargetPath = $_ + $TargetPath.Replace(\":\\\", \"$\\\") Copy-Item $WireSharkPath -Recurse $convertTargetPath -Force $WireSharkPath + \" 文件已拷贝至 \" + $convertTargetPath}#PSEXEC需要放在工作目录下，然后开始执行 $TargetHost | ForEach-Object { $CheckSharklist = Invoke-Command localhost { Set-Location $using:TargetPath; .\\tshark.exe -D } if (!$CheckSharklist) { Write-Host -ForegroundColor Red $env:COMPUTERNAME \" 检查是否安装npcap\" #Start-Sleep 5 #throw \"检查是否安装npcap\" } else { Write-Host -ForegroundColor Green ( $env:COMPUTERNAME + \" tshark.exe -D 可以正常执行\" ) }}#构造可执行代码$TargetHost | ForEach-Object { 'Write-Host -ForegroundColor Red ' + '$env:COMPUTERNAME' | Out-File $WireSharkPath\\$_.ps1 -Encoding utf8 -Force $CheckSharklist = Invoke-Command localhost { Set-Location $using:TargetPath; .\\tshark.exe -D } $CheckSharklistArray = $CheckSharklist | ForEach-Object { $_ -match \"\\d.* .*Device\" | Out-Null $Matches.values.split('.')[0] } $ExportFilename = $TargetPath + \"\\\" + $_ + \".pcapng\" $cmds = $TargetPath + \"\\tshark.exe -a duration:\" + $Seconds + \" -w \" + $ExportFilename + \" \" + (($CheckSharklistArray | ForEach-Object { \"-i\" + $_ }) -join \" \") $WireSharkPath + \"\\psexec.exe -accepteula -s \" + \"\\\\\" + $_ + \" \" + $cmds | Out-File $WireSharkPath\\$_.ps1 -Append -Encoding utf8 Write-Host -ForegroundColor Green $_ \" 脚本生成结束\"}#使用Start-Process开始执行实际代码$TargetHost | ForEach-Object { Start-Process powershell -ArgumentList $($WireSharkPath + \"\\\" + $_ + \".ps1\")}为了防止漏掉手动安装Npcap ，所以需要检查一下。最终执行大概是这样的，一个端点弹出一个窗口，执行一条命令，捕获的数据包存储在远程主机的Tshark目录中作者九叔：《微软SystemCenter2012R2私有云部署实战》图书作者，三届微软MVP。现隶属微软CSU文章属个人原创，与公司无关。" }, { "title": "【谈资】微软MVP，凭什么？", "url": "/WhatISMSMVP/", "categories": "", "tags": "微软MVP", "date": "2022-08-17 00:00:00 +0800", "snippet": "这是一个818系列，没有任何技术细节，单纯就是讲故事，故事保真。一个含蓄但又低调有力的逼需要挖掘历史的真相才能得到。利益相关：历任3届微软MVP什么是微软MVP由微软正式员工或在任MVP推荐，经由微软的审核与选拔，获选者（非微软员工）才得由微软授予的奖励活动。最早会追朔到1993年。到2003年的时候，才开始往全球发展，所以最多的能拿到的连任杯，到今年是20年。那它是干什么的呢？它是鼓励“热衷与社区分享知识的技术专家”，在中国这种人俗称自来水。也就是不用付费的水军，主动给厂商做舔狗。既然只是一个水军的代称，为什么还有这么多人去抢这个Title，想要加入到这里呢？站着挣钱时间往前十年，大厂还没有那么卷，也不是人人都在搞钱，所以单纯搞技术不会被歧视。总有人想要改变这种现状，现在来看，最搞钱的莫过于做销售，但是以前不是所有人都能看得清。那这种情况下怎么搞钱，有一条路出现了，那就是搞证。网络方面的认证，最开始是思科CCIE，通过的人少，含金量还是挺高的。但随着”题库”的出现，仿佛是打开了一扇新大门，内卷就开始了。很长一段时间，周边的朋友热衷于考证，各种MCSE/CCIE/CCNP，考了就能加薪，考了就能提换更好的工作。但是内卷可怕就可怕在，池子的水就那么多，你卷了付费的考试，其他人不卷就落后。加上题库导致通过认证的技术含量直线下降，为了认证而认证，用人单位也不再看中这些认证。默认拿到认证都是用题库过的，这让考试和认证失去了本来的初衷。本来是一种能力的证明，结果变成了充钱就能解决，公信力大幅下降。本来一个活CCNA就能干，结果卷的大家至少要考CCNP，甚至CCIE才能抢到，但最终要做的事情，又没有那么难。但是总有人不参与卷的活动，反正搞钱搞不动，就热衷于在技术圈装逼。然而技术圈装逼难度其实特别大，要想获得技术领袖的地位，真的是要台上一分钟，台下十年功。群众的眼睛是雪亮的，弄虚作假很容易被锤的头破血流。而微软干的事情就是拉拢这波热衷装逼又对技术有追求的人，通过这些人的专业地位，让他们自觉的热爱，自觉地推广产品。那么对这些人的要求只有两个： 专业 热爱分享（装逼)当然还有一个条件是年满18，为什么单独拎出来说，是因为微软真的有给卡在18岁边儿的朋友颁发过MVP，真真正正做到了一视同仁。另外下面这些东西不在微软MVP认证的考虑范畴。 职位头衔 通过的专业认证微软回馈给MVP的是什么，可以说单纯只是微软MVP这么一个头衔。他不能充钱得到，不能说我在微软每年花那么多钱，能不能分我点名额？也不能说我过了很多微软的认证，能不能免试直接拿到认证。所以但凡拿到微软MVP，就等于微软发了一个背书，说你小子专业技能好，又热衷于分享带小弟。它避免了你在面试过程中跟面试官的反复沟通，证明自己。他让你在各种社区上去使用的时候，真的就只是表明你是一个合格的技术人员。这对于不善言谈的技术人员来说，是一份沉甸甸的东西，让技术人员很快收获其他人的尊重。而这，又是技术人员非常欠缺的东西。如何获得稀缺性（每一年同时在线只有几千个）、获取手段的单一（纯技术、热爱分享），决定了微软MVP只能被纯种打工人获取，保证了队伍成分的单一性。从商业角度来说，这种方法真的不见得是最好的。微软拉拢的都是在企业中不见得有绝对话语权的技术人员，但放开到5年10年，也确实有从技术人员转型销售或管理，并且把这种和微软的友谊继承下来的情况。除了微软有MVP制度，国内其他厂商也开始了这种社区和技术人员耦合增强的制度。比如腾讯、阿里、华为，都有了自家的MVP。但是无一例外，这些MVP都有了中国式的演变，直观感受是获得MVP奖项的人员，Title都太高了，准确的说，更多的是商业上有建树的大佬。单纯的做某一项技术，很难获得奖项。只有微软，还是秉承热爱分享、钻研技术的初衷。它不是一个考试的认证，它不是说你花了钱，完了去背题库就拿到了什么东西，它不是这样的，它真的是需要你对社区有贡献，你的技术能力要足够的强，足够的深入，才能获得大家的认可。MVP圈子里其实也很卷，比如说每个社区能够对微软这边提名的名额是有限的，所以大家都在卷特定的行业，特定的技术领域。卷成什么样子呢？好比你这个季度写了10篇博客，那我就要写20篇；你写的博客只重量不重质，那我就要重质又重量。你的文章写得很口水仗，那我就要写一个带故事情节的阅读感特别强的小作文。但是最可怕的是什么，你想想这个卷最可怕的是什么？他没有钱啊，微软不给发钱，它的最直接收益就是一个Title，你可以在各个场合使用它，说我是微软的MVP，仅此而已。我们都知道不花钱的东西其实是最贵的，因为不花钱，我们相对来说可以在一个比较公平的场合去争夺这些荣誉。虽然卷，但是公平。所以你说这帮人凭什么这么硬气，凭的就是硬实力能加的动班，凭的是热心肠能拿好人卡## 开放包容很早的时候，微软MVP只针对微软产品的贡献进行提名，但是现在由于Azure云的引入，Github收购，以及众多Linux大佬加入微软，微软对于开源的东西秉持开放包容的态度，在MVP的提名上，也有很多方向是允许非微软技术体系的人申请的。像Python、Java的开发大佬也都是可以申请的。微软有一些老MVP任期已经达到10年以上，真的是一路走来一路陪伴，对微软充满信任。我们没有因为经济利益聚在一起，所以未来也不会因为经济利益有所疏远。一些福利除了使用微软MVP的Title介绍自己外，还有少量的福利可用。 一个每月150美元的Azure，任期内可用 一个MSDN订阅，有很多免费的微软产品序列号可用 参加MVP峰会，期间的住宿免费（因为疫情的缘故，这个等于无） 参加国内的各类活动以及吃饭，有微软中国的大佬参加，比如微软中国CTO 韦青。（因为疫情的缘故，已经缩减了很少，期待未来能够恢复） 认识跟你一样优秀的其他MVP的机会。" }, { "title": "随便聊聊:如何硬气的打补丁不重启", "url": "/How_abloud_hotfix_update_windows_server_2022/", "categories": "", "tags": "Windows, Server, 2022", "date": "2022-02-23 00:00:00 +0800", "snippet": "随便聊聊:为什么打补丁要重启引子我有一个朋友，因为最近微软出了很多漏洞修复补丁，导致需要频繁的打补丁。在打补丁重启之后，有些机器出现了蓝屏等等一些奇怪的问题。所以问题来了，为什么给Windows打补丁要重启，不重启行不行。结论先说结论，不重启大部分情况下是没问题的。但是不建议需要重启的理由动态链接库在分析原因之前，需要先聊一下，为什么需要重启。在聊重启之前，又要聊一下Windows的动态链接库 (DLL) 。动态链接库相当于组成乐高的不同砖块。有些是铺在底下的砖头，如果要更换这些砖头，就需要把这块砖上关联的东西都铲了（停止），才能更换。比如要拆除下图左下角的砖，换一个别的颜色。除了把整个风车拆除，别无她法。 对于Windows，操作系统的很多功能都由 DLL 提供。 此外，当您在这些操作系统中的一个Windows程序时，该程序的很多功能可能由 DLL 提供。 例如，某些程序可能包含许多不同的模块，并且程序的每个模块包含在 DLL 中并分发。 使用 DLL 有助于促进代码的模块化、代码重用、高效的内存使用并减少磁盘空间。 因此，操作系统和程序加载速度更快，运行速度更快，并且占用了更少的磁盘空间。为什么会重启知道了最重要的原理，回到为什么会重启的问题：安装安全更新后，如果满足下列条件之一，系统可能会提示您重新启动计算机： 安全更新将更新一个 DLL，该 DLL 加载在由 Windows 所需的一个或多个进程中 安全更新将更新.exe文件，该文件当前作为应用程序所需的进程Windows 安全更新将更新当前使用的设备驱动程序，以及当前Windows。 使用此设备驱动程序时无法完成更新，但是，你无法卸载此设备驱动程序，除非你关闭Windows。 安全更新对注册表进行更改。 这些更改要求您重新启动计算机。 安全更新将更改在您启动计算机时只读的注册表项。说了那么多点，在于更新的过程，可能（很大概率）会修改Windows的基石。如果细心观察，有的小伙伴可能会遇到系统提示当前无法安装补丁，会在下一次重启时安装。重启的几种状态在我们双击补丁程序之后，可能会发生以下几种情况 没有任何提示，系统不要求重启 要求重启 提示在下一次重启时进行安装。打补丁为什么会打出新问题微软的补丁有一个特色，就是可能会解决一些问题的同时，带来一些新问题。事情的根因大约可以归于动态链接库机制。不同的应用、服务、角色之间有着千丝万缕的关联。Windows上可以安装各种各样的软件、功能、角色，在补丁发版之前很难说做到万全的测试。如果很不幸的撞到了没有测试的项目上，就算中招了。再比如，安装完某个补丁后没有重启，然后开始安装新的补丁。这种场景测试人员也很难复现。更为严重的是，如果打补丁出现问题，也不见得次次都能还原回去。重启能解决什么问题回到最初的问题，虽然问题是打补丁为什么要重启（打完补丁之后重启），但在打补丁之前，我们提前重启一次，可以避免很多问题。 当前系统安装完补丁还未重启 当前系统安装完某个软件后未重启 当前系统的某个功能或角色，配置完成后还未重启如果在安装补丁之前，提前重启一次，以上问题带来的潜在风险都可以避免。检查是否需要重启在打补丁之前重启，是为了避免存在一些已经要重启了但是没重启的情况，但是这种状态可以提前查询么？答案是肯定的。当重新启动挂起时，Windows 会添加一些注册表值来显示这一点。所以要做的就是检查这些各种各样的注册表。下面的这个脚本来自Adam Bertram，作者是微软的在任MVP。直接照抄就可以了。展示效果具体是这样的PS51&gt; Test-PendingReboot.ps1 -ComputerName localhostComputerName IsPendingReboot------------ ---------------localhost False以下是测试代码。function TestPendingreboot($ComputerName){\t#功能来源：https://adamtheautomator.com/pending-reboot-registry-windows/\tif ($ComputerName -match \";\")\t{ $ComputerName = $ComputerName.split(\";\") }\t$scriptBlock = {\t\tfunction Test-RegistryKey\t\t{\t\t\t[OutputType('bool')]\t\t\t[CmdletBinding()]\t\t\tparam\t\t\t(\t\t\t\t[Parameter(Mandatory)]\t\t\t\t[ValidateNotNullOrEmpty()]\t\t\t\t[string]$Key\t\t\t)\t\t\t\t\t\t$ErrorActionPreference = 'Stop'\t\t\t\t\t\tif (Get-Item -Path $Key -ErrorAction Ignore)\t\t\t{\t\t\t\t$true\t\t\t}\t\t}\t\t\t\tfunction Test-RegistryValue\t\t{\t\t\t[OutputType('bool')]\t\t\t[CmdletBinding()]\t\t\tparam\t\t\t(\t\t\t\t[Parameter(Mandatory)]\t\t\t\t[ValidateNotNullOrEmpty()]\t\t\t\t[string]$Key,\t\t\t\t[Parameter(Mandatory)]\t\t\t\t[ValidateNotNullOrEmpty()]\t\t\t\t[string]$Value\t\t\t)\t\t\t\t\t\t$ErrorActionPreference = 'Stop'\t\t\t\t\t\tif (Get-ItemProperty -Path $Key -Name $Value -ErrorAction Ignore)\t\t\t{\t\t\t\t$true\t\t\t}\t\t}\t\t\t\tfunction Test-RegistryValueNotNull\t\t{\t\t\t[OutputType('bool')]\t\t\t[CmdletBinding()]\t\t\tparam\t\t\t(\t\t\t\t[Parameter(Mandatory)]\t\t\t\t[ValidateNotNullOrEmpty()]\t\t\t\t[string]$Key,\t\t\t\t[Parameter(Mandatory)]\t\t\t\t[ValidateNotNullOrEmpty()]\t\t\t\t[string]$Value\t\t\t)\t\t\t\t\t\t$ErrorActionPreference = 'Stop'\t\t\t\t\t\tif (($regVal = Get-ItemProperty -Path $Key -Name $Value -ErrorAction Ignore) -and $regVal.($Value))\t\t\t{\t\t\t\t$true\t\t\t}\t\t}\t\t\t\t# Added \"test-path\" to each test that did not leverage a custom function from above since\t\t# an exception is thrown when Get-ItemProperty or Get-ChildItem are passed a nonexistant key path\t\t$tests = @(\t\t\t{ Test-RegistryKey -Key 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Component Based Servicing\\RebootPending' }\t\t\t{ Test-RegistryKey -Key 'HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Component Based Servicing\\RebootInProgress' }\t\t\t{ Test-RegistryKey -Key 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\RebootRequired' }\t\t\t{ Test-RegistryKey -Key 'HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Component Based Servicing\\PackagesPending' }\t\t\t{ Test-RegistryKey -Key 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\PostRebootReporting' }\t\t\t{ Test-RegistryValueNotNull -Key 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager' -Value 'PendingFileRenameOperations' }\t\t\t{ Test-RegistryValueNotNull -Key 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Session Manager' -Value 'PendingFileRenameOperations2' }\t\t\t{\t\t\t\t# Added test to check first if key exists, using \"ErrorAction ignore\" will incorrectly return $true\t\t\t\t'HKLM:\\SOFTWARE\\Microsoft\\Updates' | ?{ test-path $_ -PathType Container } | %{\t\t\t\t\t(Get-ItemProperty -Path $_ -Name 'UpdateExeVolatile' | Select-Object -ExpandProperty UpdateExeVolatile) -ne 0\t\t\t\t}\t\t\t}\t\t\t{ Test-RegistryValue -Key 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce' -Value 'DVDRebootSignal' }\t\t\t{ Test-RegistryKey -Key 'HKLM:\\SOFTWARE\\Microsoft\\ServerManager\\CurrentRebootAttemps' }\t\t\t{ Test-RegistryValue -Key 'HKLM:\\SYSTEM\\CurrentControlSet\\Services\\Netlogon' -Value 'JoinDomain' }\t\t\t{ Test-RegistryValue -Key 'HKLM:\\SYSTEM\\CurrentControlSet\\Services\\Netlogon' -Value 'AvoidSpnSet' }\t\t\t{\t\t\t\t# Added test to check first if keys exists, if not each group will return $Null\t\t\t\t# May need to evaluate what it means if one or both of these keys do not exist\t\t\t\t('HKLM:\\SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName' | ?{ test-path $_ } | %{ (Get-ItemProperty -Path $_).ComputerName }) -ne\t\t\t\t('HKLM:\\SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ComputerName' | ?{ test-path $_ } | %{ (Get-ItemProperty -Path $_).ComputerName })\t\t\t}\t\t\t{\t\t\t\t# Added test to check first if key exists\t\t\t\t'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Services\\Pending' | Where-Object {\t\t\t\t\t(Test-Path $_) -and (Get-ChildItem -Path $_)\t\t\t\t} | ForEach-Object { $true }\t\t\t}\t\t)\t\t\t\tforeach ($test in $tests)\t\t{\t\t\tif (&amp; $test)\t\t\t{\t\t\t\t$true\t\t\t\tbreak\t\t\t}\t\t}\t}\t\tforeach ($computer in $ComputerName)\t{\t\t\t\t$connParams = @{\t\t\t'ComputerName' = $computer\t\t}\t\t\t\t\t\t$output = @{\t\t\tComputerName = $computer\t\t\tIsPendingReboot = $false\t\t}\t\t\t\t$psRemotingSession = New-PSSession @connParams\t\t\t\tif (-not ($output.IsPendingReboot = Invoke-Command -Session $psRemotingSession -ScriptBlock $scriptBlock))\t\t{\t\t\t$output.IsPendingReboot = $false\t\t}\t\t[pscustomobject]$output\t\t\t\t\t}\t}总结想一想，因为疫情的紧张，我们已经知道出门要戴口罩。 先说结论，不带口罩大部分情况下是没问题的。但是不建议同理，打补丁重启其实没什么可讨论的，当把它当做一个预防和保护措施的时候，能够节省很多麻烦。当然最重要的是，打补丁之前要做足够多的验证。随便聊聊:如何硬气的打补丁不重启上一篇文章介绍了为什么微软的系统，打补丁了要重启。这是一个既成事实，说的是如何去接受这个事实。但是今天的故事会更有一点意思，我们介绍一下特定场景中，如何做到打补丁不重启的，也就是不去接受上面的事实。虽然打补丁重启很麻烦，但是需要注意的是，在Windows 10/Windows Server 2016以后的操作系统中，我们不需要在意补丁的细节，只需要安装最新的补丁，这种补丁是累计更新的。而在Windows7以及更早的系统中，补丁的安装是这样的：早期的补丁安装方式优点和缺点同样明显： 补丁一般有专门的应对功能，相对体积较小，安装速度快。 补丁2的安装可能依赖补丁1，有时候不见得会有很明确的说明。 补丁3可能替换了补丁1，在安装补丁3的时候不需要安装补丁1。 安装补丁依然会有可能需要重启。如何做到打补丁不重启打补丁不重启不是什么高科技，这只是微软的产品功能。说到功能，就要理解一般来说，这会有限制条件。一个恰当的比喻类似于显卡的光线追踪。而在打补丁这个事情里，这项技术叫做 Azure Automanage 热补丁，他是随着Windows Server 2022的发布而带来的功能，但是这项功能又不是泛指所有的Windows Server 2022，它只支持一种操作系统 Windows Server 2022（core）再次强调一下，是Windows Server 2022的CORE版。虽然使用CORE版会减低被攻击的风险，但是没有图形界面对大多数朋友来说，应该还是会带来一些障碍的。而且也不是随便一个平台，随便一个版本就支持，它只存在下面两种环境中。 Azure（公有云） AzureStack HCI（混合云）也就是说，本地化的Windows Server 2022（零售、EA）并不支持这项功能。要在自家数据中心使用这项功能，必须要使用AzureStack HCI，而云端则必须要选择Azure。什么是 Azure Automanage 热补丁这里简单介绍一下这项功能：“Windows Server 2022 Datacenter：Azure 版本”支持 Azure Automanage 中的热补丁。 热修补是在新的 Windows Server Azure Edition 虚拟机 (VM) 上安装更新的一种新方式，安装后无需重新启动。 有关详细信息，请参阅 Azure Automanage 文档。热补丁目前处于公共预览版中。需要一个选择加入程序才能使用下面描述的功能。此预览版在没有服务级别协议的情况下提供，不建议用于生产工作负载。某些功能可能不受支持或功能受限。有关详细信息，请参阅Microsoft Azure 预览版的补充使用条款。热补丁的工作原理Hotpatch 的工作原理是首先使用 Windows 更新最新累积更新建立基线。基于该基线的热补丁会定期发布（例如，每月的第二个星期二）。热补丁将包含不需要重新启动的更新。定期（从每三个月开始）使用新的最新累积更新刷新基线。上面的话很官方，简单来说就是这样： 可以做到打补丁不重启，但是这只能坚挺三个月 每3个月会打一个基线补丁，这个时候会重启。 周而复始回到和Windows7时代的补丁机制对比，每个补丁很小，对系统的影响相对较小。但是每3个月会对齐一下基线，让补丁不至于和Win7一样乱，这对于解决补丁依赖和补丁替代，会有积极的作用。除了上面计划内的补丁安装之外，也可能会出现一些计划外的补丁，比如重大的0day，那就可能会发布新的需要重启的补丁。补丁安装的原则是这样的： 分类为“关键”或“安全”的补丁会自动下载并应用到虚拟机上。 在 VM 时区的非高峰时段应用补丁程序。 补丁编排由 Azure 管理，补丁的应用遵循可用性优先原则。 监控通过平台健康信号确定的虚拟机健康状况以检测修补故障。实现要开始在Azure上新 VM 上使用热补丁，请执行以下步骤： 启用预览访问 每个订阅都需要启用一次性预览访问权限。 可以通过 API、PowerShell 或 CLI 启用预览访问，如下面的“启用预览访问”部分所述。 从 Azure 门户开始创建新 VM 在预览期间，您需要开始使用此特定链接创建。 在 VM 创建期间提供详细信息 确保在“图像”下拉列表中选择了受支持的Windows Server Azure 版图像。使用本指南确定支持哪些图像。 在“来宾操作系统更新”部分下的“管理”选项卡上，选中“启用热补丁”复选框以在预览时评估热补丁。补丁编排选项将设置为“Azure 编排”。 在“Azure Automanage”部分下的“管理”选项卡上，为“Azure Automanage 环境”选择“开发/测试”或“生产”，以在预览时评估 Automanage 机器最佳实践。 创建你的新虚拟机补丁更新我们可以手动的对系统打一下补丁，试验一下效果，看看到底是不是真的不用重启。 在安装好的操作系统，进入来宾和主机更新→转到热补丁（预览） 在这个界面Assess updates→立即触发评估→确定 等待评估结束，可以看到能够安装的补丁会在下方列出来。 此时可以点击顶部的Manage updates→one-time update进行手动安装补丁 进行如下配置，默认不需要修改 在左侧点击+包含更新分类，勾选所有 刚才发现的补丁就可以安装了。点击下一步继续 确认无误，正式安装 右上角会出现提示正在安装。 由于补丁不大，安装很快结束。 一条正常的安装日志，大概是长这个样子的。补丁安装失败的情况处理在我的测试过程中，我发现补丁安装有失败的情况，那这个锅应该甩给热补丁么？ 检查日志，看到有如下错误提示 这里也能看到相应错误提示 前往虚拟机，查看日志，由于是个core系统，没有资源管理器，所以需要开一个notepad，然后在notepad里面，使用打开，操作这个窗口。在这里，我们可以选择单个文件，通过远程桌面，可以把文件拷贝出来。日志检查没有发现异常的地方。 检查日志过程中，发现裸机内存占用很大，远程桌面也有时会断联。 内存扩容为3.5G，裸连直接使用掉2G，因此可以下定论，Windows Server 2022比较占用内存资源，即使是CORE，也要分配4G内存。 内存扩容后，补丁安装正常，现阶段可以看出来，Windows Server 2022对系统资源要求相对较高，这一块大家一定要有心理预期。总结从我最早知道热补丁这个概念的时候，我对他的期待还是蛮高的，安装补丁要重启，重启就有可能带来各种意外的问题。所以不重启的话，就能减低出现问题的可能性。现在的功能从标配的次次重启改成了3个月重启一次。并且在Azure上，可以由Azure来托管补丁的安装过程。这对于云端用户是个利好消息。而本地化的用户呢？其实这种改变对本地化用户也有很大的影响，在本地使用需要使用Azure Stack HCI。HCI的账单会从Azure走，进行合并。如果用户没有互联网连接，也就无法使用这项功能。虽然没有做到完全的不重启打补丁，这是一种有很多前置条件的不重启，但这确实在某种程度上改变了和推进了云运维的模式。" }, { "title": "VSCode备份和搬家流程", "url": "/VSCode_backup_and_move_process/", "categories": "", "tags": "PowerShell进阶学习", "date": "2021-09-03 00:00:00 +0800", "snippet": "背景在系统重新安装或需要将自己的配置环境快速的复制到其他主机上时，可以采用此方法多系统环境下，可以通过重定向插件目录，免除在每个系统中都下载一次插件的问题在不联网的环境中，可以使用此方法将插件提前下载好，一次性解压至目标主机安装前往 https://code.visualstudio.com/ 根据操作系统下载安装即可备份数据总共需要备份两个内容，一个是插件，一个是主程序的安装目录插件目录VSCode的插件位于如下路径，将整个目录拷贝出来备用，如果调用的插件很多，则此处拷贝会比较耗时。C:\\Users\\ 你的用户名\\.vscode\\extensions安装目录安装目录根据最开始安装时的定义进行选择，默认应该是C:\\Program Files\\VScode打包文件使用自己常用的压缩工具，如7zip/WinRAR，将以上两个目录打包还原数据解压缩根据需要，将插件目录和安装目录放在自己需要的路径即可。修改映射一般来说，经过日积月累的使用，插件目录的文件都会比较多，不建议拷贝回原始的C:\\Users\\ 你的用户名\\.vscode路径，可以使用下面的方式，为插件目录增加一个链接，直接进行调用。这种配置在多系统下也是很有必要的mklink /j 需要链接的目录 真实目录#举例mklink /j C:\\Users\\ 你的用户名\\.vscode c:\\插件备份目录mklink /j C:\\Users\\kukisama\\.vscode D:\\Programs\\.vscode具体的增删例子如下，来源于微软mklink /d \\MyFolder \\Users\\User1\\Documentsmklink /h \\MyFile.file \\User1\\Documents\\example.filerd \\MyFolderdel \\MyFile.file使用小技巧切换中文 在VSCode的商店中，安装中文插件 Ctrl+Shift+P快捷键 打开命令面板。 在命令面板中，输入Configure Display Language，选择Configure Display Language命令，切换语言PowerShell代码格式化在拥有对应的插件的时候，可以用如下两个命令完成常用的操作。另外需要注意，如果修改VSCode配置文件，可以做到在刷文档的时候，自动替换别名。 操作 命令 格式化文档 Shift+Alt+F 替换别名 Shift+Alt+E 一些插件根据个人喜好安装即可，下面是我推荐的一些。 Code Runner compareit 对比 Excel Viewer 查看excel GitHub Pull Requests and Issues Inline Values support for PowerShell Powershell Extension Pack Prettier - Code formatter 代码格式化 Regexp Explain 正则检查插件 GIT vscode-icons 改变图标的颜色" }, { "title": "PowerShell使用函数时采用Switch还是Bool？", "url": "/Does_PowerShell_use_Switch_or_Bool_when_using_functions/", "categories": "", "tags": "PowerShell进阶学习", "date": "2021-08-18 00:00:00 +0800", "snippet": " 这是一篇翻译整理的稿子，相对而言比较有用，分享出来给大家。 原帖为 Using PowerShell Switch vs. Boolean Parameters in SMA Runbooks 原文发表在2013年，但是2021年依然还是有这个问题，或者说是这种设计。 看完原文只有一个感觉：解决问题生硬粗暴，完全就是解决不了问题，直接解决掉提问题的人的样子。但是还就是一点办法没有。背景知识我们在使用一些PowerShell命令的时候，会有一些特殊的参数，比如Out-File C:\\aaa.csv -Append这其中有没有-appand，对命令执行结果差异很大。（有的话表示文件追加，没有的话表示直接覆盖。）这种参数还有一个特点就是，它不需要对其赋予一个特定的值，只要写入即可。传统构造传统构造的语句是这样的，可以看到能够实现和原生命令类似的效果。function MyFunction { param([switch]$A ) if ($a -eq $true) { \"真的\" } else { \"假的\" }}#执行如下语句MyFunction假的#执行如下语句MyFunction -A真的问题现象但是在PowerShell workflow中，且套用两层workfolw的前提下，会出现错误，导致无法继续。解决方法首先考虑是，两层workflow的情况常见么？从实际使用而言，真的很常见。如果想在函数或者workflow中使用这种参数传递，只能改用如下的方法，简言之就是将switch类型改为bool。但是用了这种方法后，较为优雅的写法也无法使用了。在函数中的写法会有如下变动。function MyFunction { param([bool]$A ) if ($a -eq $true) { \"真的\" } else { \"假的\" }}注意上方的写法中，swtich被修改为bool，而使用方法也变成了下面两个例子，在输入-A后，还需要加上$true的尾巴。#执行如下语句MyFunction假的#执行如下语句MyFunction -A $true真的而workflow的写法也会变成这个样子Workflow Invoke-NestedWorkflow{ Param([bool]$SomeSwitch) \"I'm in the nested Runbook\" $SomeSwitch}Workflow Invoke-ParentWorkflow{ \"I'm in the parent Runbook\" Invoke-NestedWorkFlow -SomeSwitch $true}Invoke-ParentWorkflow问题影响如果是用纯的workflow方法来写脚本，影响还是挺大的，因为较为直观的参数调用方式会被改变，像输出文件、记录日志这种经常用参数来控制的函数/workflow，必须做一定的修改才能执行。那么用InlineScript {}的方式能否跳过这个限制呢？答案是也是不行的，同样会失败。所以解决方法唯一，使用bool来进行使用。那么为什么会有这种问题出现呢？从表现来看，有可能是workflow的线程之间交互的一些限制，导致没有正确传参。影响范围观察了一下，影响范围应该是这样的，两者缺一不可。 PowerShell的workflow脚本 需要从workflow传参不受影响的部分： 所有传参在函数内部完成，不需要workflow层级操控。因此脚本需要有意识的控制，要么修改写日志/输出文件的方法适配这种需求，要么控制不要在workflow去传递这种参数。或者更简单，不用workflow自然碰不到这问题。" }, { "title": "PowerShell代码优化2", "url": "/PowerShell_Code_Optimization_2/", "categories": "", "tags": "PowerShell优化", "date": "2021-08-12 00:00:00 +0800", "snippet": "前情提要在 文件哈希比较的代码优化一例 中，对于提高PowerShell的执行效率，我分享了几个比较有用的优化代码方法 用foreach替换管道，可以提升50%效率 不要反复计算相同的变量，需要在循环之外计算 字符串比较会比对象比较更快本次带来的故事也是基于基于查询的加速，效率提升同样让人满意。故事现在有一个对象，如下所示。这种对象非常简单，只有名字。如果我们想要找到特定的人物名称，这非常简单。因为只有一层关系，这种查询没什么可以优化的。$西游记人物 -match \"猴哥\"事实上生产当中，我们面临的情况可能是这样的，面临的对象属性众多，真正要比对的属性，也往往不在第一位比如我们的目标是，查找法号为行者的角色，展示其名字$西游记人物 |?{$_.法号 -eq \"行者\"}这种查询方式即使改成foreach，查询起来也不会太快。下面这个真实的例子，这种查询大概需要270ms。$文件列表=ls C:\\windows\\System32 -Recurse -ErrorAction SilentlyContinuemeasure-command {$文件列表|? {$_.fullname -eq \"C:\\windows\\System32\\AdvancedInstallers\"} }优化1-常规优化试试改成if-else ，同样的事情，大概170msmeasure-command {$文件列表|%{if ($_.fullname -eq \"C:\\windows\\System32\\AdvancedInstallers\"){return $_} }}复习一下上一篇学过的foreach，变成了60msmeasure-command {foreach ($文件 in $文件列表){ if ($文件.fullname -eq \"C:\\windows\\System32\\AdvancedInstallers\"){ $文件 } } }以上也是最常用的返回方式，return返回，或者不输入return，直接返回。两者有少许差异，return不会执行后续操作，具体适用场景可以自行测试。优化2 控制返回-Break和上面的例子类似，这里仅仅在if的循环里面加入了一个break，速度直接达到了2msmeasure-command {foreach ($文件 in $文件列表){ if ($文件.fullname -eq \"C:\\windows\\System32\\AdvancedInstallers\"){ $文件break } } }看起来简直超神了，但是这个优化之所以速度这么快，是有前提的。在完成一次正确匹配后，break会直接终止掉循环，所以如果你要查询的数据在数组的前面，那返回就会异常快；在最后面，则速度会逐渐接近最大值。但是不管怎么说，如果要查的结果只有一条，不会有重复的，那么用break是没有负担，但是收益巨大的。 语句 break 可以包含允许退出嵌入循环的标签。 标签可以在脚本中指定任何循环关键字，如 foreach for 、 while优化3-大杀器哈希表break属于写起来简单，用起来好用的方法。但如果说我们需要在一个脚本中频繁的查询一些数据，并提取相应数据，应该怎么做呢？还是上面西游记的例子，无论怎么优化，还都是属于常规范围，查询速度有快有慢。$西游记人物 |?{$_.法号 -eq \"行者\"}但是如果我们把对象重新构造一下，变成这个样子呢？我们要查看行者，只需要访问$西游记.行者即可。这种查询构造一个比较现实的例子，我们将原来的对象，增加了一列表头，也就是fullname,构造这个对象额外花费了250ms。根据实际情况，这里也可以使用某种唯一ID。measure-command {$新文件列表= $文件列表|%{@{$_.fullname=$_}}}接下来我们用点分表示法来使用这条数据，看看查询数据看看需要多久。我们查一个数组最近的，一个数组最远的，耗时均在20ms左右。measure-command {$新文件列表.\"C:\\windows\\System32\\0409\"}measure-command {$新文件列表.\"C:\\windows\\System32\\zh-TW\\WWAHost.exe.mui\"}哈希表为什么快这么快其实很简单，可以看看兄弟行业SQL的索引。技术都是触类旁通的。索引的优点和缺点同样明显，所以哈希表的优点和缺点也是一样明显。总结 break返回能够尽力的快速返回，速度有快有慢，但是实现简单。 哈希表速度稳定也很快，不过需要额外的时间构造哈希表。所以只适用于频繁查询的场景。 实际做过一个例子，在极限情况下，使用哈希表可以将一个需要15分钟执行完毕的脚本，提速到了只需30秒。 if-else比match快，相信很多人会感到奇怪，但是确实如此。 备考文中的例子当然属于伪命题，PowerShell有一些原生的命令，可以直接原生查询，而不用像例子这么复杂。此处仅仅只是为了演示效果。生产中总会遇到各种生成的查询对象，无法用原生命令一次性查找获得，本文所面对的情况正是如此。下一次分享，应该会基于戴尔服务器的IPMI与裸金属部署中介绍的多线程，更加详细的说明一些用法。" }, { "title": "PowerShell与i18n的思考", "url": "/PowerShell_and_i18n_thinking/", "categories": "", "tags": "PowerShell进阶学习", "date": "2021-07-23 00:00:00 +0800", "snippet": "什么是i18n i18n（其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数）是“国际化”的简称。在资讯领域，国际化(i18n)指让产品（出版物，软件，硬件等）无需做大的改变就能够适应不同的语言和地区的需要。对程序来说，在不修改内部代码的情况下，能根据不同语言及地区显示相应的界面。 在全球化的时代，国际化尤为重要，因为产品的潜在用户可能来自世界的各个角落。通常与i18n相关的还有L10n（“本地化”的简称）。有没有意义正常来说，对小项目而言是没有意义的。但是在大项目和开源项目中，为了让自己的好东西被更多人接受，我觉得i18n是很有必要的。比如4A Games，如果他没有i18n，只使用最淳朴的乌克兰语，很难说有现在的知名度。当然它也不能没有乌克兰语的支持，如果只有英语，那本地人民会念他的好么？这种恶劣行为相当于什么，相当于滴滴只有英文版，抖音上的网红没一个说中文。i18n的实现方式加密主流的方式还是加密保存语言配置文件。更有甚者，因为资源有限的问题，以前的游戏卡带厂商，还会把多国语言字库写入到ROM里面，让非官方的i18n完全没法做。。商业软件也有将多个语言文件保存为DLL或和其他乱七八糟的格式，方便调用的情况。比如Typora就是用的.pak的格式。不过商业软件的问题也不是问题。一方面近十年来看，软件中文化越来越多，厂商已经把汉化给做了，所以用什么格式存储数据是人家的自由也无伤大雅。另一方面人家也没求着你帮他做汉化对吧。不加密不加密的种类就很多了，当然处理方式也是建议，一种语言一个文件或者一组文件，而不要多语言混用。文件直接用记事本打开，可以用json，也可以是xml，甚至一行一个对象的流水账也可以。什么场景做这个想一想，某一天你做了个非常好的程序，想着去国外赚一笔狠的，美国卖了卖日本，日本卖了卖乌克兰。是为了不同软件专门重写一遍按钮和提示，还是把文字都抽象出来，专门雇个翻译两天搞定呢？结果显而易见。举个例子首先上中文代码PS C:\\windows\\system32&gt; $fullname=lsWrite-Host (\"当前目录共有\"+$fullname.count+\"个文件，其中.dll共\"+($fullname|?{$_.name -match \".dll\"}).count+\"个\")#输出当前目录共有4744个文件，其中.dll共3514个针对这个例子，我们让它支持中英双语，前面用一个简单的设置来切换。首先我们准备两个文本文件，放在c盘根目录，如图所示。英文文件三行Current directory has Files, Files of. DLL is 中文文件三行当前目录共有个文件，其中.dll共个主程序改成这样#二选一，选一个语言$lang=\"gc c:\\zh_cn.txt\",\"gc c:\\en.txt\"|Out-GridView -PassThru#加载$lang= iex $lang#程序原逻辑$fullname=lsWrite-Host ($lang[0]+$fullname.count+$lang[1]+($fullname|?{$_.name -match \".dll\"}).count+$lang[2])这样的话，会有一个弹窗让你选择语言。选择语言之后，我们看看中英文的不同反馈。原理上面只是最简单的一个例子。考虑到中文和英文之间除了单词之间要空格，甚至有表达方式的不同，你不能完全的像作文填空一样把文字完全留空出来。所以也有的翻译翻译方式就是整句带参数一起翻译，类似下面这样。这里用到了PowerShell的一个特性$arg[x]表示随便一个什么传进来的变量，不管名字不管内容，只在乎位置。当前目录共有$arg[0]个文件，其中.dll共$arg[1]个Current directory has $arg[0] Files, Files of. DLL is $arg[1]后记按照这种思路，把自己的程序中所有涉及输出的部分抽象出来，会很容易进行翻译，但是相应的，这种逻辑上的解耦，会让程序源代码变得晦涩起来。所以这种做法适合程序的模块和功能打磨的比较完善的时候进行，而不是初始的功能实现阶段。" }, { "title": "文件哈希比较的代码优化一例", "url": "/An_example_of_code_optimization_for_file_hash_comparisons/", "categories": "", "tags": "PowerShell优化", "date": "2021-07-02 00:00:00 +0800", "snippet": "背景某个场景，需要手动对业务系统替换几个文件，文件位于不同的路径下，且文件量大。在替换结束后，需要检查文件是否真的被替换了。是否被替换了合适的版本。实现检查文件有没有货不对板有多种方式。如果是exe这类正经封装过的文件，一般会有FileVersionRaw属性，属性中会有版本号，我们基于此比较就可以。但如果是脚本、文本文件这种没有版本号的，这个方法则不适用了。另外版本号也有可能会骗人，版本起名全靠作者自觉。基于此，可以使用PowerShell内置命令Get-FileHASH来比对每一个文件的哈希值，通过比对哈希值（默认SHA256），来判断文件是否被替换成正确的版本。PS C:\\windows\\system32&gt; Get-FileHash $a[888]Algorithm Hash Path --------- ---- ---- SHA256 B93A3F3DC478B4D167F26BCDEB4E4984DA997665AC79B91BCA3F1DF4E36A7E5E C:\\windows\\system32\\dafWCN.dll Get-FileHASH除了支持使用SHA256来计算外，也支持如下格式 SHA1 SHA256 SHA384 SHA512 MD5代码实现首先准备两个函数，一个用来抓数据function OutputHASHCheckFile ($Filename, $CheckPath,$OutputPath) { $CheckPath=$CheckPath.replace(':','$') $FullFile = Get-ChildItem $(\"\\\\\" + $Filename + \"\\\" + $CheckPath) -Recurse $Files = $FullFile | Where-Object { $_.Attributes -eq \"Archive\" } $FileHash = $Files | ForEach-Object { Get-FileHASH $_.FullName } \"HASH,path,FileVersion\" | Out-File $($OutputPath + $Filename + \".csv\") -Encoding utf8 $FileHash | ForEach-Object { $_.HASH + \",\" + $_.path.split('$')[-1] + \",\" + (Get-Item ($_.path)).VersionInfo.FileVersionRaw } | Out-File $($OutputPath + $Filename + \".csv\") -Encoding utf8 -Append}这里有一个大问题，就是类似C:\\windows\\system32\\dafWCN.dll 这种路径格式，当包含\\符号时，PowerShell的解析是有问题的，这个时候不能用match,但是可以用EQ ,非常之神奇。\\Windows\\System32\\zh-CN\\acledit.dll.muiPS C:\\windows\\system32&gt; PS C:\\windows\\system32&gt; $Basefile.path\\Windows\\System32\\zh-CN\\aadtb.dll.mui\\Windows\\System32\\zh-CN\\aadWamExtension.dll.mui\\Windows\\System32\\zh-CN\\AboutSettingsHandlers.dll.mui...........PS C:\\windows\\system32&gt; $Basefile.path -match $Targetfile[4].path#不同操作系统的返回不太一样，但都是返回错误PS C:\\windows\\system32&gt; $Basefile.path -eq $Targetfile[4].path\\Windows\\System32\\zh-CN\\acledit.dll.mui再做一个函数用来比对哈希值，这里用到了相对很复杂的例子，首先从目标目录中找出和基线目录中一致的目录（也就是挑出来），然后从整个目标目录中，找出来这条完整的数据（包含目录、哈希值、版本号）$Targetfile | Where-Object {$_.path -eq ($Targetfile.path -eq $temp.path) }完整代码如下function HASHCheckFile ($baselineFile, $targetFile) { Write-Host $_ -ForegroundColor Green $Basefile = Import-Csv $baselineFile $Targetfile = Import-Csv $targetFile $Basefile | ForEach-Object { $temp=$_ $identicalfile = $Targetfile | Where-Object {$_.path -eq ($Targetfile.path -eq $temp.path) } if ($identicalfile.HASH -ne $_.HASH) { Write-Host ($_.path + \" | \" + $_.Fileversion) -ForegroundColor Red } } }优化1上面代码是可以成功的,但是问题是速度太慢了。我插入了一条获取当前时间的逻辑，可以看到每一次比对文件都需要消耗1秒多，对于有1700多个文件的目录而言，就是需要消耗1700多秒。显然是无法接受的。function HASHCheckFile ($baselineFile, $targetFile) { Write-Host $_ -ForegroundColor Green $Basefile = (Import-Csv $baselineFile) $Targetfile = (Import-Csv $targetFile) $Basefile | ForEach-Object { $temp=$_ $identicalfile = $Targetfile | Where-Object {$_.path -eq ($Targetfile.path -eq $temp.path) } (Get-Date).TimeOfDay.TotalSeconds #检查时间信息 if ($identicalfile.HASH -ne $_.HASH) { Write-Host ($_.path + \" | \" + $_.Fileversion) -ForegroundColor Red } } }#可以看到输出结果，每一次查询，会消耗1秒多64498.09971164499.176708264500.2567158为什么会这么慢的？这完全是查询方式的锅。$Targetfile | Where-Object {$_.path -eq ($Targetfile.path -eq $temp.path) }那么这里面是谁慢导致的呢？我们看下面的例子。当我们单纯用EQ的方式来匹配数据的时候，只用了2ms，但是换成管道，然后在右侧使用Where-Object来进行查询呢？达到了惊人的90ms，这就差了几十倍。$a=1..10000PS C:\\windows\\system32&gt; (Measure-Command {$a -eq 22}).TotalMilliseconds2.1583PS C:\\windows\\system32&gt; (Measure-Command { $a | Where-Object { $_ -eq 22 } }).TotalMilliseconds90.061如果我们换成foreach这种循环来做呢？只需要22ms。(Measure-Command { foreach ($item in $a) { if ($item -eq 22) { Write-Host $item } } }).TotalMilliseconds2222.3433解题思路就是尽量不要在这里用管道，实在需要遍历的话，用foreach也可以。由于路径格式，包含\\符号。所以至少需要使用一次循环，这里先尝试下用foreach#脚本1function HASHCheckFile ($baselineFile, $targetFile) { Write-Host $_ -ForegroundColor Green $Basefile = (Import-Csv $baselineFile) $Targetfile = (Import-Csv $targetFile) $Basefile | ForEach-Object { $temp = $_ $identicalfile = foreach ($item in $Targetfile ) { if ($item.path -eq ($Targetfile.path -eq $temp.path)) { $item } } # $Targetfile | Where-Object {$_.path -eq ($Targetfile.path -eq $temp.path) } (Get-Date).TimeOfDay.TotalSeconds #检查时间信息 if ($identicalfile.HASH -ne $_.HASH) { Write-Host ($_.path + \" | \" + $_.Fileversion) -ForegroundColor Red } } }试试看运行效果PS C:\\windows\\system32&gt; HASHCheckFile C:\\localhost.csv C:\\localhostold.csv66598.823547566599.84708466600.892102566601.9200949看起来还是没什么改进。优化2仔细观察逻辑$Basefile | ForEach-Object { $temp = $_ $identicalfile = foreach ($item in $Targetfile ) { if ($item.path -eq ($Targetfile.path -eq $temp.path)) { $item } }会发现， if ($item.path -eq ($Targetfile.path -eq $temp.path))中的$Targetfile.path -eq $temp.path无论再简单，运算再快，还是无可避免的在循环中计算了一次。我们把它存储在变量中，重复调用一下#脚本2function HASHCheckFile ($baselineFile, $targetFile) { Write-Host $_ -ForegroundColor Green $Basefile = (Import-Csv $baselineFile) $Targetfile = (Import-Csv $targetFile) $Basefile | ForEach-Object { $temp = $_ $temppath = $Targetfile.path -eq $temp.path $identicalfile = foreach ($item in $Targetfile ) { if ($item.path -eq $temppath) { $item } } (Get-Date).TimeOfDay.TotalSeconds #检查时间信息 if ($identicalfile.HASH -ne $_.HASH) { Write-Host ($_.path + \" | \" + $_.Fileversion) -ForegroundColor Red } } }肉眼可见的速度飞快起来，执行一条大约需要0.01多一点秒（10ms）PS C:\\windows\\system32&gt; HASHCheckFile C:\\localhost.csv C:\\localhostold.csv66844.787526966844.800528666844.8115265再把逻辑里面的管道换成foreach#脚本3function HASHCheckFile ($baselineFile, $targetFile) { Write-Host $_ -ForegroundColor Green $Basefile = (Import-Csv $baselineFile) $Targetfile = (Import-Csv $targetFile) foreach ($itemnew in $Basefile) { $temp = $itemnew $temppath = $Targetfile.path -eq $temp.path $identicalfile = foreach ($item in $Targetfile ) { if ($item.path -eq $temppath) { $item } } (Get-Date).TimeOfDay.TotalSeconds #检查时间信息 if ($identicalfile.HASH -ne $temp.HASH) { Write-Host ($temp.path + \" | \" + $temp.Fileversion) -ForegroundColor Red } } }看起来接近0.006秒了（6ms）PS C:\\windows\\system32&gt; HASHCheckFile C:\\localhost.csv C:\\localhostold.csv67540.239619467540.247619567540.2526189可能是样本量太少，我将脚本完整跑一次得出结果。 脚本 执行时间 脚本2 14.0271825 脚本3 10.4654441秒 脚本1 单条执行速度太慢，不参与评比 优化310秒跑一个1700多文件的对比，基本上可以算是符合要求了，生产中用起来也没问题。不过有没有更快的呢？由于我用的是import-csv的方式加载的对象，每个对象包含了路径、哈希值以及版本号。但是对我的需求而言，如果要检查某个文件的哈希值是否匹配，那么他在(基准文件)中的记录，一定有一条完全一模一样的数据同时存在于（待查询文件）中，但凡差一个字，都不是真的一样。基于这个原理，只需要查询一次，不需要先查路径再查哈希值。也就是循环只需要做一次。所以导入数据的时候用GC进行原样导入，不转换成对象。#代码4function HASHCheckFile ($baselineFile, $targetFile) { Write-Host $_ -ForegroundColor Green $Basefile = Get-Content $baselineFile $Targetfile = Get-Content $targetFile foreach ($item in $Basefile) { $temppath = $Targetfile -eq $$item if ([string]$temppath -eq \"\") { Write-Host $$item -ForegroundColor Red } } }看看消耗时间，达到了惊人的0.48秒，把其他方式按在地上摩擦。0E259FD07FF6D8D38BB529724E965A11037AF4ED260EEF3CB3692B53B8D3BDF4,\\Windows\\System32\\zh-CN\\HVDirectAD.ps1,0.0.0.0F32626EE7F8FF0CB4A7CB5D5026E88F7F9857780CEA1D613B73D722375F8BCEF,\\Windows\\System32\\zh-CN\\PS代码格式化临时.ps1,0.0.0.00.4824708当然这种输出格式需要一点点美化，不过和效率比起来也没什么了。总结 不要反复的计算某一件事情，如果计算结果阶段一致，就一定要把它放在变量里。 用 foreach替换管道，可以明显提升效率。需要注意，foreach和foreach-object是完全不同的两个东西 用蠢萌蠢萌的字符串处理，只要能保证循环的次数少，那效率就是最高的。" }, { "title": "PowerShell快速将多行字符串转成对象", "url": "/PowerShell_quickly_turns_multiple_lines_of_strings_into_objects/", "categories": "", "tags": "PowerShell初阶学习", "date": "2021-05-25 00:00:00 +0800", "snippet": "背景写脚本的时候，总有临时想构造一堆数组的时候，正经的一个数组是下面这样的$a=1,2,3,4,5$a=\"aa\",\"bb\",\"cc\"纯数字的数字比较简单，用逗号分隔即可，字符串的对象就要前后带引号，以及逗号分隔，相对而言，构造起来不那么优雅转换可以使用下面这种方式，快速转换这种关系$aa=\"张三李四王二麻子\"($aa -split \"\\r?\\n\").Trim()这样转换出来的结果就是一行一个数据，具体的应用场景可以是测试、或者比较短小的配置文件。" }, { "title": "不会英语如何用PowerShell翻译文章标题", "url": "/How_PowerShell_tallly_translated_the_Chinese_title_into_English/", "categories": "", "tags": "PowerShell初阶学习", "date": "2021-05-25 00:00:00 +0800", "snippet": "背景Github Page要求上传文件的时候，给自己的文件一个英文名字，类似这样：kukisama.github.io/_posts/2019-12-13-WhoisZhushuiPigIncloud.markdown问题是英文认识我，我不认识它。解决方案用翻译软件是大势所趋，无论是自用还是要走国际范，让代码走出国门，Microsoft 文本翻译 API都是您的明智之选本期依然用它来实现，顺便构造一个完整的句子。功能2019-12-13-WhoisZhushuiPigIncloud.markdown首先回顾下名称，包含几个部分 2019-12-13日期形式，用-隔开 WhoisZhushuiPigIncloud 英文名称 .markdown后缀根据这个，构造一下代码代码范例可以看一下这里里面加了一个狗尾续貂的过程，主要是因为Json解释上的不同，实际想要是这样的格式[ { \"text\": \"不会英语如何用PowerShell翻译文章标题\" }]但是如果不是数组（也即是只有一条数据）的话，这个Json会成这个样子{ \"text\": \"不会英语如何用PowerShell翻译文章标题\"}接下来开始翻译部分的工作#输入你的订阅，订阅需要自己在Azure上创建$subscriptionKey = '这里是订阅ID'$postParams = @{ \"Ocp-Apim-Subscription-Key\" = \"$subscriptionKey\" }#构造一个主逻辑函数function translatorMS ($language, $texts){\t$APIuri = \"https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&amp;to=$language\" \t$translatordata = Invoke-WebRequest $APIuri ` -Body $texts -ContentType \"application/json;charset=utf-8\" -Method POST -Headers $postParams\t($translatordata.Content | ConvertFrom-Json).translations.text}#构造转换Jsonfunction TranslatorTitle ($text){$text = $text,\"\"| ForEach-Object { $_ | Select-Object @{name = 'text'; e = { $_} }} | ConvertTo-Json(translatorMS -language \"en\" -texts $text)[0]}####正文 TranslatorTitle PowerShell如何高大上的将中文标题翻译成英文 #############输出结果 How PowerShell tallly translated the Chinese title into English然后是字符串和时间的组合，以后就是一句话搞定function TitlePlus ($text){ $title=(TranslatorTitle $text).replace(' ','_') (get-date -Format yyyy-MM-dd-)+$title+'.markdown' } TitlePlus PowerShell如何高大上的将中文标题翻译成英文2021-05-25-How_PowerShell_tallly_translated_the_Chinese_title_into_English.markdown一点儿细节代码到这就完成了 用的时候把它集成在别的工具里面 比如点击一个按钮后，检查剪贴板，开始翻译 翻译结束右下角弹窗，并将结果塞进剪贴板 到网页上一黏贴，齐活儿。" }, { "title": "开启MFA多因素后，AzureCli如何自动化登录", "url": "/AzureCliandMFAHowToAutomaticlogon/", "categories": "", "tags": "PowerShell进阶学习", "date": "2020-11-11 00:00:00 +0800", "snippet": "需求由于AzureRM的PowerShell模块逐渐退出历史舞台，所以Azure的自动化登录要做一个比较大的返工，用AZ来做一个代码重构。难点公司发给员工的Azure账户使用了MFA（多因素认证），安全的同时，这也导致以前的PowerShell脚本无法使用了针对开启MFA的账户，又想继续使用自动化的朋友来说，service principal解决起来相对比较简单。从官网这里获取资讯，开始改造代码 这里的主要逻辑是，使用MFA后，你不可以使用账号密码的形式，在PowerShell中登录。需要使用如下3要素： 应用ID 应用密码 租户ID以及搭配 Connect-AzAccount -ServicePrincipal 的方式去登录。应用ID和密码那么如何获取应用ID和应用密码呢？我们可以在Azure的Portal中，使用Azure Cloud Shell登录进去，或者在本地使用 Connect-AzAccount -UseDeviceAuthentication的方式，先登录一下Azure。然后执行如下的逻辑 #这里SPN2是随便起的 $sp = New-AzADServicePrincipal -DisplayName SPN2警告: Assigning role 'Contributor' over scope '/subscriptions/xxxxx6-c9d0-4d95-8122-4f289f72ec2a' to the new service principal. Account SubscriptionName TenantId Environment------- ---------------- -------- -----------xxxx-b6c7-4947-8ecb-0ceb7d1c9d62 500块 xxx-86f1-41af-91ab-xxxxx AzureCloud 执行完毕后，这个$sp对象已经拥有了我们后面要做的事情的部分信息租户ID通过PowerShell连接，我们还需要一个租户ID信息，这个可以通过图形界面获取，下图所示的位置。Portal→Azure Active Directory→属性或者直接访问，这是最简单的方法。 https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/Properties当然在已登录的PowerShell中也是可以的$tenantId = (Get-AzContext).Tenant.Id应用密码解密现在有了$sp对象，应用ID就是 $sp.ApplicationId，应用密码就是$sp.secret。但是问题是，sp.secret是个标准PowerShell加密的对象。 下面的方法可以帮你解密(仅限本机) $securestring=$sp.Secret$ptr = [System.Runtime.InteropServices.Marshal]::SecureStringToGlobalAllocUnicode($secureString)$serverpass = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($ptr) # $serverpass就是我们要的应用密码$Secure=$serverpass|ConvertTo-SecureString -AsPlainText -Force $pscredential2 = New-Object -TypeName System.Management.Automation.PSCredential(\"3f4e8213-b6c7-4947-8ecb-xxxx\", $Secure)#此处前半部分就是应用IDConnect-AzAccount -ServicePrincipal -Credential $pscredential -Tenant 72f988bf-86f1-41af-91ab-xxxx#此处后半部分为租户ID。 执行命令之后，系统会告诉你，本地存了一个json文件，事实上，这个json文件中也有我们刚才所需要的3种属性。虽然这个加密聊胜于无，但是总比没有强。并且密码是一个guid串，而不是让我们手动输入，从这点来说，密码遗失不会让你的其他业务受到损失删除连接当你使用disConnect-AzAccount的时候，那么这个json文件会被清空。如果不使用断开连接，那么何时打开PowerShell，都会自动连接到这个订阅。我们断连一下,可以看到Type是SPN类型的。 disConnect-AzAccountId : 3f4e8213-b6c7-4947-8ecb-0ceb7d1c9d62Type : ServicePrincipalTenants : {xxxxx-86f1-41af-91ab-xxxx}AccessToken : Credential : TenantMap : {}CertificateThumbprint : ExtendedProperties : {[Subscriptions, xxx-c9d0-4d95-8122-xxx], [Tenants, xxx-86f1-41af-91ab-xxx], [ServicePrincipalSecret, 440cb042- 0243-xxx-8031-xxx]}世界友好另外连接的时候可以指定云的区域，这一点是和以前一致的，方便我们登陆祖国云、国际云、德国美国云。 PS C:\\Users\\a9y&gt; Get-AzEnvironmentName Resource Manager Url ActiveDirectory Authority Type ---- -------------------- ------------------------- ---- AzureChinaCloud https://management.chinacloudapi.cn/ https://login.chinacloudapi.cn/ Built-inAzureCloud https://management.azure.com/ https://login.microsoftonline.com/ Built-inAzureGermanCloud https://management.microsoftazure.de/ https://login.microsoftonline.de/ Built-inAzureUSGovernment https://management.usgovcloudapi.net/ https://login.microsoftonline.us/ Built-inConnect-AzAccount -Environment AzureChinaCloud管理账号权限可以在AAD中如下位置进行配置。应用程序ID看起来和一个账号也是类似的。更多细节我也在研究" }, { "title": "戴尔服务器的IPMI与裸金属部署", "url": "/DellIPMIBaremetaldeployment/", "categories": "", "tags": "PowerShell进阶学习", "date": "2020-08-27 00:00:00 +0800", "snippet": "需求最近手里有一批戴尔的R740XD服务器需要批量装系统。以前针对华为浪潮中兴联想的机器，都可以通过开源的IPMI工具ipmitool来进行批量配置。实际上 也只是借用了两个功能 配置系统使用UEFI启动模式 配置系统的一次性引导（仅下一次重启时选择的启动项目，例如光驱、U盘、PXE或者本地磁盘、BIOS界面等）为PXE启动，默认从硬盘启动。问题在于戴尔的做法有少许不同，导致实现起来花了很多心思。这就有点象吃惯了萝卜白菜（没有什么定制化）的IPMI管理界面，突然来一顿四川火锅，上下实在都受不了。这里讨论的都是批量的前提，如果单纯是手工点选，任何厂商都没有任何差异什么是IPMI智能平台管理接口（Intelligent Platform Management Interface）原本是一种Intel架构的企业系统的周边设备所采用的一种工业标准。IPMI亦是一个开放的免费标准，用户无需支付额外的费用即可使用此标准。IPMI 能够横跨不同的操作系统、固件和硬件平台，可以智能的监视、控制和自动回报大量服务器的运作状况，以降低服务器系统成本。简言之，IPMI是一个微型的操作系统，用来管理真实的物理设备像远程KVM，开关机、配置BIOS这些都可以做。特别是大部分的IPMI都可以用命令行操作。戴尔的IPMI官方帮助可以看这里戴尔这里其实真的是好心，重新设计了IPMI，包装成了iDRAC 这么一个东西，现在最新的版本已经是iDRAC9了。跟它适配的命令行IPMI工具就叫做racadm。当然这种集成的事情，华为和联想也都有完整产品。获取这个工具的唯一前提或者说要求是，你需要一台戴尔服务器的序列号。然后去官网搜索下载适用于 Windows 的 Dell EMC Systems Management Tools and Documentation DVD ISO，现在最新的版本现在是v.9.4.0安装好后，可以提取出大概这么一个目录，我将IPMI工具也混合在了一起，接下来就可以干事了痛点问题不叫问题，叫==痛点==顾名思义，就是很难搞的地方。先整理一下我们通过图形界面或者进入BIOS来实际要做的工作 重启计算机 进入BIOS 调整系统为UEFI模式 保存后再次重启，配置一次性启动为PXE，以及调整硬盘为第一启动设备。 之后的操作就是正常的通过PXE安装系统，过程不表。通过racadmget bios.BiosBootSettings.UefiBootSeq可以检查现在UEFI的启动设备有哪些。get bios.BiosBootSettings.SetBootOrderEn则可以列出哪些条目支持启动，比如网卡、硬盘。在这里它是以一个字符串，中间用逗号隔开，例如RAID.Slot.6-1,NIC.PxeDevice.1-1。最初的想法是用set的相关命令，将RAID.Slot.6-1,NIC.PxeDevice.1-1替换成NIC.PxeDevice.1-1，RAID.Slot.6-1，可惜的是这种方法==并不好用==。不仅如此，IPMI常用的一次性引导的配置也是有问题的。另外还有一个问题，从BIOS切换到UEFI后，部分RAID卡在不开启HddPlaceholder的时候，是识别不到本地磁盘的。这个新的配置让打工仔的生活雪上加霜。除此之外，IPMI的配置过程其实并不是实时生效，它相当于准备一个配置文件，然后再下次重启的时候，进入生命周期管理器中，把配置写入到BIOS中。从重启到修改结束，这个过程大概需要3到5分钟。流程梳理基于这个前提，重新设计IPMI的配置过程（纯命令实现）。 修改UEFI并设置计划任务，重启生效 修改HddPlaceholder，确认可以认到磁盘。默认情况下第一启动设备是PXE，正好符合我们的要求，到这里就可以开始装机了。 PXE服务器开始裸金属推送。因为调整磁盘顺序的命令并不好用，所以采用一个折中的方法：启动设备只留硬盘，将PXE放到不允许启动的配置选项卡下。同时设置计划任务，不做任何修改，等下次重启再进行修改。 这里最最关键的地方在于，配置磁盘启动顺序不能是立即配置，必须要等待PXE将服务器启动起来之后，然后进行配置。代码实现加一点点细节就可以了。为了提升代码可读性，将部分代码存在模块里面。同时因为戴尔做了二次封装，导致命令执行起来很慢，这里用到了之前我的文章介绍过的多线程技术首先是模块function PSMultithreading ($Throttle, $allnodename, $ScriptBlock) { #线程，需要操作的对象，脚本块 $RunspacePool = [RunspaceFactory]::CreateRunspacePool(1, $Throttle) $RunspacePool.Open() $Jobs = @() $allnodename | ForEach-Object { $Job = [powershell]::Create().AddScript($ScriptBlock).AddArgument($_) $Job.RunspacePool = $RunspacePool $Jobs += New-Object PSObject -Property @{ Server = $_ Pipe = $Job Result = $Job.BeginInvoke() } } Write-Host \"请等待..\" -NoNewline Do { Write-Host \".\" -NoNewline Start-Sleep -Seconds 1 } While ( $Jobs.Result.IsCompleted -contains $false) Write-Host \"作业已完成\" -BackgroundColor Green $global:Results = @() ForEach ($Job in $Jobs) { $global:Results += $Job.Pipe.EndInvoke($Job.Result) } }function servers ($path, $matchx) { $csv = Import-Csv -Path $path $Global:servers = $csv | Where-Object { $_.servername -MATCH $matchx } | Sort-Object servername $servers | ForEach-Object { $_.servername + \",\" + $_.ip + \",\" + ((ping $_.ip -n 1 -w 50) -match \"Reply from .*\") }}function DELLipmi ($ip, $Scripts) { $IPMItemp = 'C:\\racadm\\racadm.exe -u root -p calvin -r ' + $ip + \" \" + $Scripts cmd /c $IPMItemp}function WH1 ($servername, $ip ) { #Write-Host $servername -NoNewline -ForegroundColor Red #Write-Host $ip -NoNewline -BackgroundColor DarkGreen Write-Host (($IPMIoutput -match \"=\")[-1]) -NoNewline -ForegroundColor Green Write-Host \"\" $($servername + ',' + $ip + \",\")}function IPMICheckAndSet ($code) { $IPMIoutput = DELLipmi $ip $code ($IPMIoutput -match \"=\")[-1] }function DELLOutputInfomation ($count, $ScriptBlock, $servers) { $arrayx = $servers | ForEach-Object { $_.servername + \"|\" + $_.ip } PSMultithreading $count $arrayx $ScriptBlock $Results | Sort-Object}function PrepIPandServername ($StringX) { $StringSplit = $StringX.Split('|') $global:ip = $StringSplit[1] $global:servername = $StringSplit[0] }然后是主要调用逻辑Import-Module C:\\DELLipmiModule.psm1servers -path C:\\cd03.csv -matchx \"Wc|Sc\"#单条测试使用如下语句#$ip=\"IP\"#$servername=\"机器名\" #IPMICheckAndSet \"get bios.BiosBootSettings.SetBootOrderEn\"#检查UEFI启动条目或者第一启动项目，注意pending$ScriptBlock = { Param ([string]$StringX ) Import-Module C:\\DELLipmiModule.psm1 PrepIPandServername $StringX IPMICheckAndSet 'get bios.BiosBootSettings.SetBootOrderEn' #IPMICheckAndSet \"get bios.BiosBootSettings.UefiBootSeq\"}DELLOutputInfomation 10 $ScriptBlock $servers#开启HDD检测，UEFI引导，加一个计划任务，要求强制重启$ScriptBlock = { Param ([string]$StringX ) Import-Module C:\\DELLipmiModule.psm1 PrepIPandServername $StringX IPMICheckAndSet 'set bios.BiosBootSettings.bootmode Uefi' IPMICheckAndSet 'set bios.BiosBootSettings.HddPlaceholder Enabled' IPMICheckAndSet 'jobqueue create BIOS.Setup.1-1 -s TIME_NOW -r forced'}DELLOutputInfomation 10 $ScriptBlock $servers #修改启动顺序，特定磁盘在前面，并且不强制重启$ScriptBlock = { Param ([string]$StringX ) Import-Module C:\\DELLipmiModule.psm1 PrepIPandServername $StringX IPMICheckAndSet “set bios.BiosBootSettings.SetBootOrderEn RAID.Slot.6-1” IPMICheckAndSet “set bios.BiosBootSettings.SetBootOrderDis NIC.PxeDevice.1-1” IPMICheckAndSet 'jobqueue create BIOS.Setup.1-1 -s TIME_NOW -r none'}DELLOutputInfomation 10 $ScriptBlock $servers #纯IPMI 重启机器$servers | ForEach-Object { C:\\racadm\\ipmitool.exe -I lanplus -H $_.ip -U root -P calvin chassis power reset } " }, { "title": "SDNExpress部署流程与经验总结", "url": "/SDNExpress_deployment_process_and_experience_summary/", "categories": "", "tags": "SDN", "date": "2020-04-11 00:00:00 +0800", "snippet": "概述SDNExpress是微软开源发布的，用以快速部署SDN基础架构的PowerShell脚本，包括NC/MUX/GW。不依赖System Center产品。部署环境需要有足够的背景知识，请提前阅读《 使用 SDN Express 部署 SDN 基础设施》，以了解技术点。准备耗时准备充分，硬件能够保障的情况下，50分左右完成了部署（32G内存，200G可用空间，I7 6820HQ）视频我在bilibili放了一个视频，可以点击连接直达，和本文配合阅读。(手机版应该可以看到下面的图，电脑版看不到，很奇怪。)硬件需求以最小的1NC、2MUX、2GW的部署来计算，至少需要如下硬件资源。这不是推荐配置，而是最小配置 资源 需求量 VHD操作系统 10G 虚拟机功能 DC/HV主机/虚拟路由，共3台 虚拟机内存 2G-16G-2G 网络 1个”内部网络”类型的虚拟交换机 VLAN 不要设置VLAN 虚拟机硬盘 总至少130G，推荐256G 虚拟化 开启嵌套虚拟化，开启MAC地址欺骗 嵌套虚拟机CPU内存配比 2C2G 虚拟机 功能 POCXX-DC01 Active Directory域控制器 POCXX-DCGW 安装了RRAS角色的不加域虚拟机，用来做软路由 POCXX-HV01 承载SDN基础架构的虚拟机，开启嵌套虚拟化 网络 功能 VLAN 192.148.0.0/24 物理主机网络 TBD 192.148.11.0/24 管理网络 TBD 192.148.12.0/24 PA子网 TBD 192.148.13.0/24 TBD TBD 192.148.14.0/24 PrivateVIP TBD 192.148.15.0/24 PublicVIP TBD 获取代码首先获取 https://github.com/microsoft/SDN/tree/master/SDNExpress/scripts 所需的脚本。 以下流程以人肉汉化的脚本为例进行。除了内容输出和原版有差异外，其他完全一致。前置条件准备 准备Windows Server 2019 with 2020 2月补丁的物理主机 Sysprep一个VHDX文件，用来安装操作系统 创建一个”内部网络”类型的虚拟交换机，名称不限 创建一台虚拟机，命名为POCXX-DC01，至少分配2C2G。安装Active Directory域角色 创建一台虚拟机，命名为POCXX-DCGW，至少分配2C2G。 创建一台虚拟机，命名为POCXX-HV01，至少分配4C16G。开启网卡欺骗和嵌套虚拟化准备配置文件由于SDNExpress的安装流程依赖配置文件，配置文件可以通过GUI生成，但逐个属性介绍比较繁琐。直接修改如下配置文件即可，注意文中注释部分，基本不需要修改部署出来的虚拟机时区和跑脚本的主机一致，所以在跑脚本之前，需要先正确配置时间## 如果准备的VHDX文件是图形界面的话，一定要输入AVMA的key。Core模式则无所谓## 此处指定了VLAN，除非在生产环境部署，否则不需要关心此处 @{ ScriptVersion = '2.0' VHDPath = 'C:\\HV' VHDFile = 'TemplateVHDXGUI.vhdx' VMLocation = 'c:\\hv' JoinDomain = 'contoso.com'## 2019 AVMA的序列号 ProductKey =\"H3RNG-8C32Q-Q8FRX-6TDXV-WMBMW\"## 不指定硬件配置，此处默认为8C8G VMMemory=2GB VMProcessorCount=4 ManagementVLANID = '11' ManagementSubnet = '192.148.11.0/24' ManagementGateway = '192.148.11.1' ManagementDNS = @('192.148.0.2' ) ## 此处加域密码、本地密码均被删除，只有通过GUI界面生成配置文件后，才能保存密码。此处注释掉密码，脚本部署过程中，会要求输入密码，根据提示输入即可。 DomainJoinUsername = 'contoso\\administrator' LocalAdminDomainUser = 'contoso\\administrator' #NCFC的终结点地址 RestName = 'ncfcnew.contoso.com' #工作的HV主机列表，支持数组，此处使用pocxx-hv01 HyperVHosts = @('pocxx-hv01' ) NCs = @( @{ ComputerName = 'pocxNC01' HostName = 'pocxx-hv01' ManagementIP = '192.148.11.30' MACAddress = '00:1D:D8:B7:1C:00' } ) Muxes = @( @{ ComputerName = 'pocxMux01' HostName = 'pocxx-hv01' ManagementIP = '192.148.11.31' MACAddress = '00-1D-D8-B7-1C-01' PAIPAddress = '192.148.12.81' PAMACAddress = '00-1D-D8-B7-1C-02' }, @{ ComputerName = 'pocxMux02' HostName = 'pocxx-hv01' ManagementIP = '192.148.11.32' MACAddress = '00-1D-D8-B7-1C-03' PAIPAddress = '192.148.12.82' PAMACAddress = '00-1D-D8-B7-1C-04' } ) Gateways = @( @{ ComputerName = 'pocxGW01' HostName = 'pocxx-hv01' ManagementIP = '192.148.11.33' MACAddress = '00-1D-D8-B7-1C-05' FrontEndIp = '192.148.12.83' FrontEndMac = '00-1D-D8-B7-1C-06' BackEndMac = '00-1D-D8-B7-1C-07' }, @{ ComputerName = 'pocxGW02' HostName = 'pocxx-hv01' ManagementIP = '192.148.11.34' MACAddress = '00-1D-D8-B7-1C-08' FrontEndIp = '192.148.12.84' FrontEndMac = '00-1D-D8-B7-1C-09' BackEndMac = '00-1D-D8-B7-1C-0A' } ) ## NC的密码被删除，需要在输入环节中输入。 NCUsername = 'contoso\\administrator' PAVLANID = '12' PASubnet = '192.148.12.0/24' PAGateway = '192.148.12.1' PAPoolStart = '192.148.12.83' PAPoolEnd = '192.148.12.140' SDNMacPoolStart = '00-1D-D8-B7-1C-0B' SDNMacPoolEnd = '00:1D:D8:B7:1F:FF' ## BGP相关配置 SDNASN = '65001' Routers = @( @{ RouterASN = '65002' RouterIPAddress = '192.148.17.1' } ) PrivateVIPSubnet = '192.148.14.0/24' PublicVIPSubnet = '192.148.15.0/24' PoolName = 'DefaultAll' GRESubnet = '192.148.16.0/24' Capacity = '10000'}禁用VLAN功能由于在嵌套虚拟化环境中测试，网络不能带有VLAN标签，而SDNExpress的脚本默认会启用VLAN功能，且图形界面下为强制选项。注释掉脚本相关部分会简单一些。从193行开始，图片中标注的几个部分已经被注释。部署配置软路由由于部署过程需要使用到很多个网段，不同网段之间没有网络设备是不通的。除非拥有BGP交换设备和足够的物理主机，否则不应在环境中配置VLAN。使用脚本完成软路由配置，利用到PowerShell Direct功能，相对比较快速。配置要点请关注注释部分#输入DCGW的账号密码$cred=Get-Credential$vmname=\"pocxx-dcgw\"#验证主机是否已开机icm -VMName $vmname -Credential $cred {$env:COMPUTERNAME}#安装RRAS，大概率不需要重启。icm -VMName $vmname -Credential $cred {Install-WindowsFeature RemoteAccess -IncludeAllSubFeature -IncludeManagementTools -Restart} #创建检查点Get-VM -Name $vmname |Checkpoint-VM -SnapshotName \"完成功能安装\"#给默认网卡改名和IP，在初次部署的时候完成修改也可以icm -VMName $vmname -Credential $cred { Get-NetAdapter |Rename-NetAdapter -NewName \"0\"\t$themac = (Get-NetAdapter).MacAddress.replace('-',':')\t$wmi = Get-WmiObject win32_networkadapterconfiguration | ?{ $_.macaddress -eq $themac }\t$wmi.EnableStatic(\"192.148.0.1\", \"255.255.255.0\");\t$wmi.SetGateways(\"192.148.0.1\", 1);\t$wmi.SetDNSServerSearchOrder(\"192.148.0.2\");}#增加5张网卡，设置VLAN，在虚拟机内部，将其改名。由于WMI调用的问题，出错之后，不见得可以重新配置 11..15|%{$tempx=$_Add-VMNetworkAdapter -SwitchName POC -Name $tempx -VMName $vmname #这里VLANID是没有意义的，不用配置#Set-VMNetworkAdapterVlan -VMName $vmname -VMNetworkAdapterName $tempx -VlanId 1000 -Accessicm -VMName $vmname -Credential $cred {Get-NetAdapter -Name \"以太网*\" |Rename-NetAdapter -NewName $using:tempx #设置IP地址，以及配置掩码$IPtemp=\"192.148.\"+$using:tempx+\".1\"New-NetIPAddress -InterfaceAlias $using:tempx -AddressFamily IPv4 -IPAddress $IPtempSet-NetIPAddress -InterfaceAlias $using:tempx -AddressFamily IPv4 -PrefixLength 24sleep 1} } #创建检查点Get-VM -Name $vmname |Checkpoint-VM -SnapshotName \"完成网卡配置\"#检查名称和VLAN配置Get-VMNetworkAdapterVlan -VMName $vmname#关闭防火墙icm -VMName $vmname -Credential $cred {Set-NetFirewallProfile -Enabled False}#无图形界面，仅开启路由功能icm -VMName $vmname -Credential $cred {Install-RemoteAccess -VpnType RoutingOnly }确认准备好的内容 此时应该有3台虚拟机，位于同一台物理主机上 1台AD，域名为 contoso.com 1台软路由，没有加域 1台开启嵌套虚拟化的虚拟机，安装Hyper-V角色，并保证有足够的可用磁盘空间和内存 另外注意，这台嵌套虚拟化虚拟机，要开启MAC欺骗，以及在这个虚拟机内要创建一个外部交换机 3台虚拟机位于同一个物理主机上 一个Syspre后的叫做TemplateVHDXGUI的VHDX文件位于C:\\hv目录下注意事项： 仅仅在嵌套虚拟化中测试完成 现在看起来似乎物理主机上，只有一张网卡连接网线才能部署成功。 物理主机能否使用脚本，和网卡型号、驱动均有关联。 Domain Admin需要隶属于DNS admins运行脚本在Scripts脚本目录中，管理员PowerShell下运行如下命令PS C:\\scripts&gt; .\\SDNExpress.ps1 -ConfigurationDataFile '.\\peizhi 1.psd1'## 日志记录 如果正确部署的话，日志大概是这个样子的。由于代码进行了汉化，输出内容也基本都是中文的。从日志大致也能看出，部署分为多个部分，因此在测试阶段，我们也可以有目的的分开执行。例如第一部分部署虚拟机，大约会耗时15分钟，此处如果单独执行，成功后即进行快照，可以节省部署失败后重来的时间。配置NC环节，大致需要10分钟，此处也可以同样的分步骤进行执行。另外日志最后的部分，提示MUX还存在问题，这是正常的，只有提前根据BGP的信息配置peer后，这里才会连接成功。 [20200324-16:53:33] ***开始SDN Express部署***[20200324-16:53:33] 参数集：ConfigurationFile[20200324-16:53:33] -ConfigurationDataFile：.\\peizhi 1.psd1[20200324-16:53:33] -ConfigurationData：[20200324-16:53:33] -SkipValidation：False[20200324-16:53:34] -SkipDeployment：False[20200324-16:53:34] 使用通过参数传入的配置文件.[20200324-16:53:34] 在命令行或配置文件中找不到凭据.提示.[20200324-16:55:37] 在命令行中使用凭据.[20200324-16:55:37] 在命令行或配置文件中找不到凭据.提示.[20200324-16:55:39] 在命令行中使用凭据.[20200324-16:55:39] 在命令行或配置文件中找不到凭据.提示.[20200324-16:55:40] 在命令行中使用凭据.[20200324-16:55:40] 阶段1：创建VM[20200324-16:55:40] 阶段1.1：创建NC VM[20200324-16:55:40] 新的SDNExpressVM[20200324-16:55:40] -ComputerName:pocxx-hv01[20200324-16:55:40] -VMLocation:c:\\hv[20200324-16:55:40] -VMName:pocxNC01[20200324-16:55:40] -VHDSrcPath:C:\\HV[20200324-16:55:40] -VHDName:TemplateVHDXGUI.vhdx[20200324-16:55:40] -VMMemory:2147483648[20200324-16:55:40] -SwitchName:[20200324-16:55:40] -Nics:[20200324-16:55:40] Management, Mac:00:1D:D8:B7:1C:00, IP:192.148.11.30/24, GW:192.148.11.1, DNS:192.148.0.2, VLAN:[20200324-16:55:40] -CredentialDomain:contoso[20200324-16:55:40] -CredentialUserName:administrator[20200324-16:55:40] -CredentialPassword:********[20200324-16:55:40] -JoinDomain:contoso.com[20200324-16:55:40] -LocalAdminPassword:********[20200324-16:55:40] -DomainAdminDomain:contoso[20200324-16:55:40] -DomainAdminUserName:administrator[20200324-16:55:40] -产品密钥: ********[20200324-16:55:40] -VMProcessorCount:4[20200324-16:55:40] -Locale:zh-CN[20200324-16:55:40] -TimeZone:China Standard Time[20200324-16:55:40] -角色:NetworkController NetworkControllerTools[20200324-16:55:42] 检查pocxx-hv01 上的路径是否为CSV.[20200324-16:55:43] 路径不是CSV.[20200324-16:55:43] 将\\\\pocxx-hv01\\VMShare\\pocxNC01 用作VHD复制的目标.[20200324-16:55:43] 正在检查以前安装的映像.[20200324-16:55:44] 查找虚拟交换机.[20200324-16:55:44] 将VM附加到虚拟交换机:POC[20200324-16:55:44] 创建VM根目录并在主机上共享.[20200324-16:55:46] 创建VM目录并复制VHD.这可能需要几分钟.[20200324-16:55:46] 从\\\\pocxx-hv01\\VMShare\\pocxNC01[20200324-16:56:44] 创建安装目录并安装VHD.[20200324-16:56:52] 离线添加角色(NetworkController NetworkControllerTools)以保存以后的重启[20200324-16:57:39] 生成unattend.xml[20200324-16:57:39] 将unattend.xml写入C:\\Users\\Administrator\\AppData\\Local\\Temp\\tmp4EEC.tmp \\ unattend.xml[20200324-16:57:39] 打扫干净[20200324-16:57:46] 创建虚拟机:pocxx-hv01[20200324-16:57:50] New-SDNExpressVM已完成.[20200324-16:57:50] 第1.2阶段：创建Mux VM[20200324-16:57:50] 新的SDNExpressVM[20200324-16:57:50] -ComputerName:pocxx-hv01[20200324-16:57:50] -VMLocation:c:\\hv[20200324-16:57:50] -VMName:pocxMux01[20200324-16:57:50] -VHDSrcPath:C:\\HV[20200324-16:57:50] -VHDName:TemplateVHDXGUI.vhdx[20200324-16:57:50] -VMMemory:2147483648[20200324-16:57:50] -SwitchName:[20200324-16:57:50] -Nics:[20200324-16:57:50] Management, Mac:00-1D-D8-B7-1C-01, IP:192.148.11.31/24, GW:192.148.11.1, DNS:192.148.0.2, VLAN:[20200324-16:57:50] HNVPA, Mac:00-1D-D8-B7-1C-02, IP:192.148.12.81/24, GW:, DNS:, VLAN:[20200324-16:57:50] -CredentialDomain:contoso[20200324-16:57:50] -CredentialUserName:administrator[20200324-16:57:50] -CredentialPassword:********[20200324-16:57:50] -JoinDomain:contoso.com[20200324-16:57:50] -LocalAdminPassword:********[20200324-16:57:50] -DomainAdminDomain:contoso[20200324-16:57:50] -DomainAdminUserName:administrator[20200324-16:57:50] -产品密钥: ********[20200324-16:57:50] -VMProcessorCount:4[20200324-16:57:50] -Locale:zh-CN[20200324-16:57:50] -TimeZone:China Standard Time[20200324-16:57:50] -角色:SoftwareLoadBalancer[20200324-16:57:51] 检查pocxx-hv01 上的路径是否为CSV.[20200324-16:57:52] 路径不是CSV.[20200324-16:57:52] 将\\\\pocxx-hv01\\VMShare\\pocxMux01 用作VHD复制的目标.[20200324-16:57:52] 正在检查以前安装的映像.[20200324-16:57:52] 查找虚拟交换机.[20200324-16:57:53] 将VM附加到虚拟交换机:POC[20200324-16:57:53] 创建VM根目录并在主机上共享.[20200324-16:57:54] 创建VM目录并复制VHD.这可能需要几分钟.[20200324-16:57:54] 从\\\\pocxx-hv01\\VMShare\\pocxMux01[20200324-16:58:42] 创建安装目录并安装VHD.[20200324-16:59:02] 离线添加角色(SoftwareLoadBalancer)以保存以后的重启[20200324-16:59:30] 生成unattend.xml[20200324-16:59:30] 将unattend.xml写入C:\\Users\\Administrator\\AppData\\Local\\Temp\\tmp1B31.tmp \\ unattend.xml[20200324-16:59:30] 打扫干净[20200324-17:02:37] 创建虚拟机:pocxx-hv01[20200324-17:02:41] New-SDNExpressVM已完成.[20200324-17:02:41] 新的SDNExpressVM[20200324-17:02:41] -ComputerName:pocxx-hv01[20200324-17:02:41] -VMLocation:c:\\hv[20200324-17:02:41] -VMName:pocxMux02[20200324-17:02:41] -VHDSrcPath:C:\\HV[20200324-17:02:41] -VHDName:TemplateVHDXGUI.vhdx[20200324-17:02:41] -VMMemory:2147483648[20200324-17:02:41] -SwitchName:[20200324-17:02:41] -Nics:[20200324-17:02:41] Management, Mac:00-1D-D8-B7-1C-03, IP:192.148.11.32/24, GW:192.148.11.1, DNS:192.148.0.2, VLAN:[20200324-17:02:41] HNVPA, Mac:00-1D-D8-B7-1C-04, IP:192.148.12.82/24, GW:, DNS:, VLAN:[20200324-17:02:41] -CredentialDomain:contoso[20200324-17:02:41] -CredentialUserName:administrator[20200324-17:02:41] -CredentialPassword:********[20200324-17:02:41] -JoinDomain:contoso.com[20200324-17:02:41] -LocalAdminPassword:********[20200324-17:02:41] -DomainAdminDomain:contoso[20200324-17:02:41] -DomainAdminUserName:administrator[20200324-17:02:41] -产品密钥: ********[20200324-17:02:41] -VMProcessorCount:4[20200324-17:02:41] -Locale:zh-CN[20200324-17:02:41] -TimeZone:China Standard Time[20200324-17:02:41] -角色:SoftwareLoadBalancer[20200324-17:02:43] 检查pocxx-hv01 上的路径是否为CSV.[20200324-17:02:44] 路径不是CSV.[20200324-17:02:44] 将\\\\pocxx-hv01\\VMShare\\pocxMux02 用作VHD复制的目标.[20200324-17:02:44] 正在检查以前安装的映像.[20200324-17:02:44] 查找虚拟交换机.[20200324-17:02:44] 将VM附加到虚拟交换机:POC[20200324-17:02:44] 创建VM根目录并在主机上共享.[20200324-17:02:46] 创建VM目录并复制VHD.这可能需要几分钟.[20200324-17:02:46] 从\\\\pocxx-hv01\\VMShare\\pocxMux02[20200324-17:03:29] 创建安装目录并安装VHD.[20200324-17:03:53] 离线添加角色(SoftwareLoadBalancer)以保存以后的重启[20200324-17:04:20] 生成unattend.xml[20200324-17:04:20] 将unattend.xml写入C:\\Users\\Administrator\\AppData\\Local\\Temp\\tmp7D15.tmp \\ unattend.xml[20200324-17:04:20] 打扫干净[20200324-17:04:29] 创建虚拟机:pocxx-hv01[20200324-17:04:34] New-SDNExpressVM已完成.[20200324-17:04:34] 阶段1.3：创建网关VM[20200324-17:04:34] 新的SDNExpressVM[20200324-17:04:34] -ComputerName:pocxx-hv01[20200324-17:04:34] -VMLocation:c:\\hv[20200324-17:04:34] -VMName:pocxGW01[20200324-17:04:34] -VHDSrcPath:C:\\HV[20200324-17:04:34] -VHDName:TemplateVHDXGUI.vhdx[20200324-17:04:34] -VMMemory:2147483648[20200324-17:04:34] -SwitchName:[20200324-17:04:34] -Nics:[20200324-17:04:34] Management, Mac:00-1D-D8-B7-1C-05, IP:192.148.11.33/24, GW:192.148.11.1, DNS:192.148.0.2, VLAN:[20200324-17:04:34] FrontEnd, Mac:00-1D-D8-B7-1C-06, IP:192.148.12.83/24, GW:, DNS:, VLAN:[20200324-17:04:34] BackEnd, Mac:00-1D-D8-B7-1C-07, IP:, GW:, DNS:, VLAN:[20200324-17:04:34] -CredentialDomain:contoso[20200324-17:04:34] -CredentialUserName:administrator[20200324-17:04:34] -CredentialPassword:********[20200324-17:04:34] -JoinDomain:contoso.com[20200324-17:04:34] -LocalAdminPassword:********[20200324-17:04:34] -DomainAdminDomain:contoso[20200324-17:04:34] -DomainAdminUserName:administrator[20200324-17:04:34] -产品密钥: ********[20200324-17:04:34] -VMProcessorCount:4[20200324-17:04:34] -Locale:zh-CN[20200324-17:04:34] -TimeZone:China Standard Time[20200324-17:04:34] -角色:[20200324-17:04:36] 检查pocxx-hv01 上的路径是否为CSV.[20200324-17:04:37] 路径不是CSV.[20200324-17:04:37] 将\\\\pocxx-hv01\\VMShare\\pocxGW01 用作VHD复制的目标.[20200324-17:04:37] 正在检查以前安装的映像.[20200324-17:04:37] 查找虚拟交换机.[20200324-17:04:38] 将VM附加到虚拟交换机:POC[20200324-17:04:38] 创建VM根目录并在主机上共享.[20200324-17:04:39] 创建VM目录并复制VHD.这可能需要几分钟.[20200324-17:04:39] 从\\\\pocxx-hv01\\VMShare\\pocxGW01[20200324-17:05:49] 创建安装目录并安装VHD.[20200324-17:05:56] 生成unattend.xml[20200324-17:05:56] 将unattend.xml写入C:\\Users\\Administrator\\AppData\\Local\\Temp\\tmpA0D1.tmp \\ unattend.xml[20200324-17:05:56] 打扫干净[20200324-17:06:02] 创建虚拟机:pocxx-hv01[20200324-17:06:07] New-SDNExpressVM已完成.[20200324-17:06:07] 新的SDNExpressVM[20200324-17:06:07] -ComputerName:pocxx-hv01[20200324-17:06:07] -VMLocation:c:\\hv[20200324-17:06:07] -VMName:pocxGW02[20200324-17:06:07] -VHDSrcPath:C:\\HV[20200324-17:06:07] -VHDName:TemplateVHDXGUI.vhdx[20200324-17:06:07] -VMMemory:2147483648[20200324-17:06:08] -SwitchName:[20200324-17:06:08] -Nics:[20200324-17:06:08] Management, Mac:00-1D-D8-B7-1C-08, IP:192.148.11.34/24, GW:192.148.11.1, DNS:192.148.0.2, VLAN:[20200324-17:06:08] FrontEnd, Mac:00-1D-D8-B7-1C-09, IP:192.148.12.84/24, GW:, DNS:, VLAN:[20200324-17:06:08] BackEnd, Mac:00-1D-D8-B7-1C-0A, IP:, GW:, DNS:, VLAN:[20200324-17:06:08] -CredentialDomain:contoso[20200324-17:06:08] -CredentialUserName:administrator[20200324-17:06:08] -CredentialPassword:********[20200324-17:06:08] -JoinDomain:contoso.com[20200324-17:06:08] -LocalAdminPassword:********[20200324-17:06:08] -DomainAdminDomain:contoso[20200324-17:06:08] -DomainAdminUserName:administrator[20200324-17:06:08] -产品密钥: ********[20200324-17:06:08] -VMProcessorCount:4[20200324-17:06:08] -Locale:zh-CN[20200324-17:06:08] -TimeZone:China Standard Time[20200324-17:06:08] -角色:[20200324-17:06:09] 检查pocxx-hv01 上的路径是否为CSV.[20200324-17:06:10] 路径不是CSV.[20200324-17:06:10] 将\\\\pocxx-hv01\\VMShare\\pocxGW02 用作VHD复制的目标.[20200324-17:06:10] 正在检查以前安装的映像.[20200324-17:06:10] 查找虚拟交换机.[20200324-17:06:11] 将VM附加到虚拟交换机:POC[20200324-17:06:11] 创建VM根目录并在主机上共享.[20200324-17:06:13] 创建VM目录并复制VHD.这可能需要几分钟.[20200324-17:06:13] 从\\\\pocxx-hv01\\VMShare\\pocxGW02[20200324-17:07:07] 创建安装目录并安装VHD.[20200324-17:07:31] 生成unattend.xml[20200324-17:07:31] 将unattend.xml写入C:\\Users\\Administrator\\AppData\\Local\\Temp\\tmpD1FF.tmp \\ unattend.xml[20200324-17:07:31] 打扫干净[20200324-17:07:38] 创建虚拟机:pocxx-hv01[20200324-17:07:44] New-SDNExpressVM已完成.[20200324-17:07:44] 阶段2：网络控制器配置[20200324-17:07:44] 等待1200 秒使 pocxNC01 处于活动状态.[20200324-17:07:45] 试图与pocxNC01 联系.[20200324-17:07:59] pocxNC01 处于活动状态.继续进行部署.[20200324-17:07:59] New-SDNExpressNetworkController[20200324-17:07:59] -ComputerNames:pocxNC01[20200324-17:07:59] -RestName:ncfcnew.contoso.com[20200324-17:07:59] -ManagementSecurityGroup:[20200324-17:07:59] -ClientSecurityGroup:[20200324-17:07:59] -凭据:contoso\\administrator[20200324-17:07:59] -Force:False[20200324-17:07:59] 通过查找REST响应来检查Controller是否已经部署.[20200324-17:08:00] 网络控制器不存在, 将继续.[20200324-17:08:00] 在所有计算机上并行设置属性并添加NetworkController角色.[20200324-17:08:31] 创建本地临时目录.[20200324-17:08:31] 临时目录是:C:\\Users\\Administrator\\AppData\\Local\\Temp\\tmp1907.tmp[20200324-17:08:31] 在以下位置创建REST证书:pocxNC01[20200324-17:10:13] 临时将证书导出到我的商店.[20200324-17:10:14] REST证书指纹:75D206BEDC70923A4F7C04B79F1B24BDA955209C[20200324-17:10:14] 将REST证书导出到临时目录中的PFX和CER.[20200324-17:10:15] 将REST证书(仅公用密钥)导入到根存储中.[20200324-17:10:15] 从我的商店中删除REST证书.[20200324-17:10:15] 在每个NC节点的我的存储和根存储中安装REST证书.[20200324-17:10:15] 将REST证书安装到[20200324-17:10:26] 为:[20200324-17:11:56] 将.[20200324-17:12:01] 使用节点配置网络控制器角色:pocxNC01[20200324-17:21:51] 网络控制器群集创建完成.[20200324-17:21:51] 检查REST响应.[20200324-17:21:51] 网络控制器没有响应.将在10秒后重试.[20200324-17:22:01] 网络控制器没有响应.将在10秒后重试.[20200324-17:22:11] 网络控制器没有响应.将在10秒后重试.[20200324-17:22:43] 网络控制器没有响应.将在10秒后重试.[20200324-17:22:56] 等待60秒, 以使控制器有时间稳定下来.[20200324-17:23:56] 网络控制器设置已完成，并且可以使用.[20200324-17:23:56] New-SDNExpressNetworkController退出[20200324-17:23:56] 阶段2.1：获取REST认证指纹，以便在本地根存储中找到它.[20200324-17:24:03] New-SDNExpressVirtualNetworkManagerConfiguration[20200324-17:24:04] -RestName:ncfcnew.contoso.com[20200324-17:24:04] -MacAddressPoolStart:00-1D-D8-B7-1C-0B[20200324-17:24:04] -MacAddressPoolEnd:00:1D:D8:B7:1F:FF[20200324-17:24:04] -NCHostCert:75D206BEDC70923A4F7C04B79F1B24BDA955209C[20200324-17:24:04] -NCUsername:contoso\\administrator[20200324-17:24:04] -NCPassword:********[20200324-17:24:04] -凭据:contoso\\administrator[20200324-17:24:04] 写Mac Pool[20200324-17:24:15] 写控制器凭据.[20200324-17:24:16] 写域凭据.[20200324-17:24:17] 编写PA逻辑网络.[20200324-17:24:19] New-SDNExpressVirtualNetworkManagerConfiguration退出[20200324-17:24:19] get-ipaddressinsubnet[20200324-17:24:20] -子网:192.148.14.0/24[20200324-17:24:20] -Offset:1[20200324-17:24:20] get-ipaddressinsubnet返回192.148.14.1[20200324-17:24:20] get-ipaddressinsubnet[20200324-17:24:20] -子网:192.148.14.0/24[20200324-17:24:20] -Offset:1[20200324-17:24:20] get-ipaddressinsubnet返回192.148.14.1[20200324-17:24:20] Get-IPLastAddressInSubnet[20200324-17:24:20] -子网:192.148.14.0/24[20200324-17:24:21] rightbits:8[20200324-17:24:21] 完整字节[20200324-17:24:21] Get-IPLastAddressInSubnet返回192.148.14.255[20200324-17:24:21] get-ipaddressinsubnet[20200324-17:24:21] -子网:192.148.15.0/24[20200324-17:24:21] -Offset:1[20200324-17:24:21] get-ipaddressinsubnet返回192.148.15.1[20200324-17:24:21] Get-IPLastAddressInSubnet[20200324-17:24:21] -子网:192.148.15.0/24[20200324-17:24:22] rightbits:8[20200324-17:24:22] 完整字节[20200324-17:24:22] Get-IPLastAddressInSubnet返回192.148.15.255[20200324-17:24:22] New-SDNExpressLoadBalancerManagerConfiguration[20200324-17:24:22] -RestName:ncfcnew.contoso.com[20200324-17:24:22] -PrivateVIPPrefix:192.148.14.0/24[20200324-17:24:22] -PublicVIPPrefix:192.148.15.0/24[20200324-17:24:22] -SLBMVip:192.148.14.1[20200324-17:24:23] -PrivateVIPPoolStart:192.148.14.1[20200324-17:24:23] -PrivateVIPPoolEnd:192.148.14.255[20200324-17:24:23] -PublicVIPPoolStart:192.148.15.1[20200324-17:24:23] -PublicVIPPoolEnd:192.148.14.255[20200324-17:24:23] -凭据:contoso\\administrator[20200324-17:24:23] get-ipaddressinsubnet[20200324-17:24:23] -子网:192.148.14.0/24[20200324-17:24:23] -Offset:0[20200324-17:24:24] get-ipaddressinsubnet返回192.148.14.0[20200324-17:24:25] get-ipaddressinsubnet[20200324-17:24:26] -子网:192.148.15.0/24[20200324-17:24:26] -Offset:0[20200324-17:24:26] get-ipaddressinsubnet返回192.148.15.0[20200324-17:24:29] New-SDNExpressLoadBalancerManagerConfiguration退出[20200324-17:24:29] Add-SDNExpressVirtualNetworkPASubnet[20200324-17:24:29] -RestName:ncfcnew.contoso.com[20200324-17:24:30] -AddressPrefix:192.148.12.0/24[20200324-17:24:30] -VLANID:12[20200324-17:24:30] -DefaultGateways:192.148.12.1[20200324-17:24:30] -IPPoolStart:192.148.12.83[20200324-17:24:30] -IPPoolStart:192.148.12.140[20200324-17:24:30] -凭据:contoso\\administrator[20200324-17:24:30] -LogicalNetworkName:HNVPA[20200324-17:24:30] -Servers:[20200324-17:24:31] -AllServers:False[20200324-17:24:31] PA逻辑子网尚不存在, 正在创建.[20200324-17:24:32] 更新指定的服务器.[20200324-17:24:32] 找到了0个服务器.[20200324-17:24:33] Add-SDNExpressVirtualNetworkPASubnet退出[20200324-17:24:33] 阶段3：主机配置[20200324-17:24:33] New-SDNExpressHost[20200324-17:24:33] -RestName:ncfcnew.contoso.com[20200324-17:24:33] -ComputerName:pocxx-hv01[20200324-17:24:33] -HostPASubnetPrefix:192.148.12.0/24[20200324-17:24:33] -VirtualSwitchName:[20200324-17:24:33] -NCHostCert:75D206BEDC70923A4F7C04B79F1B24BDA955209C[20200324-17:24:34] -iDNSIPAddress:[20200324-17:24:34] -iDNSMacAddress:[20200324-17:24:34] -凭据:contoso\\administrator[20200324-17:24:34] 获取SLBM VIP[20200324-17:24:34] SLBM VIP是192.148.14.1[20200324-17:25:42] 创建并返回主机证书.[20200324-17:26:22] 将NC主机证书安装到主机上的根存储中.[20200324-17:26:23] 重新启动NC主机代理并启用VFP.[20200324-17:26:25] 配置并启动SLB主机代理.[20200324-17:26:26] 准备服务器对象.[20200324-17:26:29] Certdata包含800个字节.[20200324-17:26:30] 新服务器对象.[20200324-17:26:34] 配置DNS PRoxy.[20200324-17:26:45] New-SDNExpressHost出口[20200324-17:26:45] 阶段4：多路复用器配置[20200324-17:26:45] 等待1200 秒使 pocxMux01 处于活动状态.[20200324-17:26:46] 试图与pocxMux01 联系.[20200324-17:26:54] pocxMux01 处于活动状态.继续进行部署.[20200324-17:26:54] 等待1200 秒使 pocxMux02 处于活动状态.[20200324-17:26:54] 试图与pocxMux02 联系.[20200324-17:27:02] pocxMux02 处于活动状态.继续进行部署.[20200324-17:27:02] New-SDNExpressMux[20200324-17:27:02] -RestName:ncfcnew.contoso.com[20200324-17:27:02] -ComputerName:pocxMux01[20200324-17:27:02] -NCHostCert:75D206BEDC70923A4F7C04B79F1B24BDA955209C[20200324-17:27:03] -PAMacAddress:00-1D-D8-B7-1C-02[20200324-17:27:03] -LocalPeerIP:192.148.12.81[20200324-17:27:03] -MuxASN:65001[20200324-17:27:03] -Routers:System.Collections.Hashtable[20200324-17:27:03] -凭据:contoso\\administrator[20200324-17:27:03] 要在多路复用器中添加到PA适配器的PA子网:192.148.12.0/24 192.148.17.1/32[20200324-17:27:16] 等待1200 秒使 pocxMux01 处于活动状态.[20200324-17:27:16] 试图与pocxMux01 联系.[20200324-17:27:20] pocxMux01 处于活动状态.继续进行部署.[20200324-17:28:09] 添加VirtualServerToNC[20200324-17:28:09] Certdata包含798个字节.[20200324-17:28:12] New-SDNExpressMux完成[20200324-17:28:12] New-SDNExpressMux[20200324-17:28:12] -RestName:ncfcnew.contoso.com[20200324-17:28:12] -ComputerName:pocxMux02[20200324-17:28:12] -NCHostCert:75D206BEDC70923A4F7C04B79F1B24BDA955209C[20200324-17:28:12] -PAMacAddress:00-1D-D8-B7-1C-04[20200324-17:28:13] -LocalPeerIP:192.148.12.82[20200324-17:28:13] -MuxASN:65001[20200324-17:28:13] -Routers:System.Collections.Hashtable[20200324-17:28:13] -凭据:contoso\\administrator[20200324-17:28:13] 要在多路复用器中添加到PA适配器的PA子网:192.148.12.0/24 192.148.17.1/32[20200324-17:28:25] 等待1200 秒使 pocxMux02 处于活动状态.[20200324-17:28:25] 试图与pocxMux02 联系.[20200324-17:28:31] pocxMux02 处于活动状态.继续进行部署.[20200324-17:29:09] 添加VirtualServerToNC[20200324-17:29:09] Certdata包含798个字节.[20200324-17:29:10] New-SDNExpressMux完成[20200324-17:29:10] 阶段5：网关配置[20200324-17:29:11] Get-IPAddressInSubnet[20200324-17:29:11] -子网:192.148.16.0/24[20200324-17:29:11] -Offset:1[20200324-17:29:11] Get-IPAddressInSubnet返回192.148.16.1[20200324-17:29:11] Get-IPLastAddressInSubnet[20200324-17:29:11] -子网:192.148.16.0/24[20200324-17:29:12] rightbits:8[20200324-17:29:12] 完整字节[20200324-17:29:12] Get-IPLastAddressInSubnet返回192.148.16.255[20200324-17:29:12] 新的SDNExpressGatewayPool[20200324-17:29:12] -RestName:ncfcnew.contoso.com[20200324-17:29:12] -凭据:contoso\\administrator[20200324-17:29:12] -PoolName:DefaultAll[20200324-17:29:12] -IsTypeAll:True[20200324-17:29:13] -IsTypeIPSec:False[20200324-17:29:13] -IsTypeGre:False[20200324-17:29:13] -IsTypeForwarding:False[20200324-17:29:13] -PublicIPAddress:[20200324-17:29:13] -GRESubnetAddressPrefix:192.148.16.0/24[20200324-17:29:13] -GrePoolStart:192.148.16.1[20200324-17:29:14] -GrePoolEnd:192.148.16.255[20200324-17:29:14] -容量:10000[20200324-17:29:14] -RedundantCount:1[20200324-17:29:15] get-ipaddressinsubnet[20200324-17:29:15] -子网:192.148.16.0/24[20200324-17:29:16] -Offset:0[20200324-17:29:16] get-ipaddressinsubnet返回192.148.16.0[20200324-17:29:18] New-SDNExpressGatewayPool完成[20200324-17:29:18] 等待1200 秒使 pocxGW01 处于活动状态.[20200324-17:29:18] 试图与pocxGW01 联系.[20200324-17:29:26] pocxGW01 处于活动状态.继续进行部署.[20200324-17:29:26] 等待1200 秒使 pocxGW02 处于活动状态.[20200324-17:29:26] 试图与pocxGW02 联系.[20200324-17:29:33] pocxGW02 处于活动状态.继续进行部署.[20200324-17:29:33] 新的SDNExpressGateway[20200324-17:29:33] -RestName:ncfcnew.contoso.com[20200324-17:29:34] -ComputerName:pocxGW01[20200324-17:29:34] -HostName:pocxx-hv01[20200324-17:29:34] -NCHostCert:75D206BEDC70923A4F7C04B79F1B24BDA955209C[20200324-17:29:34] -PoolName:DefaultAll[20200324-17:29:34] -FrontEndLogicalNetworkName:HNVPA[20200324-17:29:34] -FrontEndAddressPrefix:192.148.12.0/24[20200324-17:29:34] -FrontEndIp:192.148.12.83[20200324-17:29:34] -FrontEndMac:00-1D-D8-B7-1C-06[20200324-17:29:35] -BackEndMac:00-1D-D8-B7-1C-07[20200324-17:29:35] -RouterASN:[20200324-17:29:35] -RouterIP:[20200324-17:29:35] -LocalASN:65001[20200324-17:29:35] -Routers:System.Collections.Hashtable[20200324-17:29:35] -凭据:contoso\\administrator[20200324-17:31:55] 重新启动pocxGW01, 最多等待10分钟以使Powershell远程返回.[20200324-17:32:47] 重新启动完成, 安装RemoteAccess多租户和GatewayService.[20200324-17:33:09] 配置证书.[20200324-17:33:18] 将网络接口添加到网络控制器.[20200324-17:33:27] 在网关VM NIC上设置端口数据.[20200324-17:33:30] 将虚拟服务器添加到网络控制器.[20200324-17:33:31] 将网关添加到网络控制器.[20200324-17:33:31] New-SDNExpressGateway完成[20200324-17:33:32] 新的SDNExpressGateway[20200324-17:33:32] -RestName:ncfcnew.contoso.com[20200324-17:33:32] -ComputerName:pocxGW02[20200324-17:33:32] -HostName:pocxx-hv01[20200324-17:33:32] -NCHostCert:75D206BEDC70923A4F7C04B79F1B24BDA955209C[20200324-17:33:32] -PoolName:DefaultAll[20200324-17:33:32] -FrontEndLogicalNetworkName:HNVPA[20200324-17:33:33] -FrontEndAddressPrefix:192.148.12.0/24[20200324-17:33:33] -FrontEndIp:192.148.12.84[20200324-17:33:33] -FrontEndMac:00-1D-D8-B7-1C-09[20200324-17:33:33] -BackEndMac:00-1D-D8-B7-1C-0A[20200324-17:33:33] -RouterASN:[20200324-17:33:33] -RouterIP:[20200324-17:33:34] -LocalASN:65001[20200324-17:33:34] -Routers:System.Collections.Hashtable[20200324-17:33:34] -凭据:contoso\\administrator[20200324-17:36:13] 重新启动pocxGW02, 最多等待10分钟以使Powershell远程返回.[20200324-17:36:58] 重新启动完成, 安装RemoteAccess多租户和GatewayService.[20200324-17:37:21] 配置证书.[20200324-17:37:31] 将网络接口添加到网络控制器.[20200324-17:37:32] 在网关VM NIC上设置端口数据.[20200324-17:37:35] 将虚拟服务器添加到网络控制器.[20200324-17:37:36] 将网关添加到网络控制器.[20200324-17:37:37] New-SDNExpressGateway完成[20200324-17:37:37] 测试-SDNExpressHealth[20200324-17:37:37] -RestName:ncfcnew.contoso.com[20200324-17:37:37] -凭据:contoso\\administrator[20200324-17:37:37] 服务器状态:[20200324-17:37:37] POCXX-HV01.contoso.com状态:Success[20200324-17:37:37] 辅助状态:[20200324-17:37:38] pocxMux01.contoso.com状态:Failure[20200324-17:37:38] pocxMux02.contoso.com状态:Failure[20200324-17:37:38] 网关状态:[20200324-17:37:38] pocxGW01.contoso.com状态:Redundant, Healthy[20200324-17:37:38] pocxGW02.contoso.com状态:Passive, Unmonitored[20200324-17:37:39] SDN Express部署完成.附录两段脚本供参考。#将domain admin 加入到dns admin中$cred=Get-Credential$vmname=\"pocxx-dc01\"icm -VMName $vmname -Credential $cred { Add-ADGroupMember -Identity \"DNSadmins\" -Members \"Domain admins\"(Get-ADGroup \"Domain admins\" -Properties memberof).memberof}#给HV01增加MAC欺骗，以及开启一个外部交换机Set-VMNetworkAdapter -VMName \"pocxx-HV01\" -MacAddressSpoofing On $cred=Get-Credential$vmname=\"pocxx-HV01\"icm -VMName $vmname -Credential $cred { New-VMSwitch \"POC\" -NetAdapterName (Get-NetAdapter).name -AllowManagementOS $true}" }, { "title": "如何廉价的组装192G内存的测试平台", "url": "/How_to_better_save_money/", "categories": "", "tags": "硬件", "date": "2020-03-18 00:00:00 +0800", "snippet": "前言 每一个打工仔都有一个梦想，就是要有一台更快的电脑。这和男人永远想要更贵的表，女人想要更贵的化妆品一样，永无止尽背景介绍整套环境其实是慢慢悠悠凑起来的，期间也更换过几次。不感兴趣的可以直接到文末看推荐配置和价格汇总。期间经过了多次倒腾，基本上算是告一段落流水第一次购买2016年10月，第一次买主要是想测试Azure， Stack，考虑的主要是性价比，怎么便宜怎么来，当然造型也就特别的寒酸。当时选了 戴尔C6100的主板，纯主板，只要200块 CPU用的E5620两颗，这是一个4核8线程的U，一颗大概是50块。 内存是12根8G的，凑够96G。85一根，内存花费1020 在这个列表之外，买了一个SAMA的电源，230块。 其他都是一些零配件 硬盘零零散散的找了几块退役的小HDD，总之HDD的速度非常不理想。第二次购买因为长期外出打工，这机器开机应该不到100小时。现在CPU内存主板已经有了，还缺硬盘。AzureStack需要最少3块数据盘，以及一块系统盘，所以我在2018年10月附近，买入了一波硬盘 4块Intel的545S的固态硬盘，256G容量，总价1220因为主板自带的SATA非常不给力，所以购入了一张HBA卡,把硬盘都接到新卡上，现在AzureStack的实验能够更好的完成了。 95一块，HBA卡。另外这次消费也属于被消费，主要是当时AzureStack的POC环境，不知道被哪个混球改了需求配置，最低部署需要128G内存，以及12个物理核的CPU（也就是说至少两个6核CPU）而当时内存槽也不够了，所以换换换。 230一根，买入16G内存8根。 80一块，买入6核L5640两颗当时内存价格也是过山车，还好在一个合适的机会，我以1750的价格卖了之前的96G。所以完全不亏啊不亏啊不亏啊 1750卖出之前的96G第三次购买由于内存波动太厉害，到2019年5月的时候，跌到了130一根16G，简直就是白给，我买入了4根平仓，现在手里就一共有192G内存。另外一个原因是，传闻AzureStack又来一次军备竞赛，内存需求改成了192………… 230一根买入8根 130一根买入4根 总价1840+520=2360 如果是现在买的话（2020.3），16G reg 1333的内存大概175，总价2100.第四次购买服务器一直裸奔，到了19年8月，实在是无聊，就买了一台戴尔的R610,1U服务器，有6个2.5寸硬盘槽位。 价格没看错，带远程管理，带一个电源，带另个散热器以及4个硬盘托架，只要550.开机之后发现，CPU和内存192满配的时候，标配502W电源无法开机。那时候还比较淳朴，想着再来一颗肯定就起来了呗，所以下单。结果买回来之后还是不能开机，网上一搜才知道，要买700W电源。所以当初为了平仓买的一共两颗500W电源就砸手里了。继续买700W电源，终于顺利的做朋友了。总结最终方案就是这样了 内存：192G 2360 硬盘：256G 4块 intel 545s 1220 服务器：戴尔R610 带远程管理 550 CPU：L5640 160两颗 HBA卡加线：150左右 总价 4440如果现在购买的话，大概价格是这样，而且硬盘也没必要买那么小的了。 内存：192G 2100 硬盘：480G 4块 HP/intel/toshiba JD购买，按照一块480计 1920 服务器：戴尔R610 380+50运费 CPU：X5650 190两颗 HBA卡加线：150左右 总价 4790费用大头在于内存和硬盘，觉得用不上，可以酌情减少全新购买，现在也可以买E5-26XX的CPU，性能更好。" }, { "title": "PowerShell批量查询域内主机磁盘剩余空间", "url": "/PowerShellCheckDiskFreeSpace/", "categories": "", "tags": "PowerShell进阶学习", "date": "2020-01-16 00:00:00 +0800", "snippet": "简单实现 几个需要关注的地方： 1、找出所有需要检查的主机名称，从Active Directory域中直接获取会很方便 2、确认能够访问的主机（ping），不能访问的不去检测磁盘。 3、针对能够访问的主机，检测本地磁盘可用空间和可用空间占比#找出xxxou下的所有主机$AllComputers = Get-ADComputer -Filter * -SearchScope Subtree -SearchBase \"CN=Computers,DC=contoso,DC=com\"#定义一个函数，确认主机是否存活。#这里使用了Write-Host，它只会在屏幕出现，不会被写入变量。可以方便排错。function CheckDOA ($ComputerName) { $sum = ping $ComputerName -w 100 -n 1 if ($sum -match \"TTL\") { $ComputerName Write-Host $ComputerName\"可通信\" -BackgroundColor Green } else { Write-Host $ComputerName\"不可通信，请检查\" -BackgroundColor Red }}#定义一个检查磁盘空间情况的函数，这里用到了针对数字的格式化，{0:n1}为保留一位小数function CheckCSpace ($ComputerName) { Invoke-Command $ComputerName { $data = Get-PSDrive C $env:COMPUTERNAME + \",剩余空间 \" + [string]('{0:n1}' -f ($data.Free / 1GB)) + \" GB\" + \",剩余空间占比 \" + ('{0:n1}' -f ($data.Free / ($data.Used + $data.Free) * 100 ) + \"%\" ) }}#进行检查$liveComputers = $AllComputers.name | ForEach-Object { CheckDOA $_ }CheckCSpace $liveComputers可供改进的方向 整个查询逻辑使用foreach，是顺序执行的，可以改为并发逻辑，批量执行。 CheckCSpace部分使用的是icm，默认会有30线程，无需刻意修改。$Throttle = 100 #线程$ScriptBlock = { Param ( [string]$ComputerName ) function CheckIP ($ComputerName) { $sum = ping $ComputerName -w 100 -n 1 if ($sum -match \"TTL\") { $ComputerName Write-Host $ComputerName\"可通信\" -BackgroundColor Green } else { Write-Host $ComputerName\"不可通信，请检查\" -BackgroundColor Red } } CheckIP $ComputerName }#创建一个资源池，指定多少个runspace可以同时执行$RunspacePool = [RunspaceFactory]::CreateRunspacePool(1, $Throttle)$RunspacePool.Open()$Jobs = @() $AllComputers.name | ForEach-Object { $Job = [powershell]::Create().AddScript($ScriptBlock).AddArgument($_) $Job.RunspacePool = $RunspacePool $Jobs += New-Object PSObject -Property @{ Server = $_ Pipe = $Job Result = $Job.BeginInvoke() }} #循环输出等待的信息.... 直到所有的job都完成 Write-Host \"Waiting..\" -NoNewlineDo { Write-Host \".\" -NoNewline Start-Sleep -Seconds 1} While ( $Jobs.Result.IsCompleted -contains $false)Write-Host \"作业已完成\" -BackgroundColor Green#输出结果 $Results = @()ForEach ($Job in $Jobs) { $Results += $Job.Pipe.EndInvoke($Job.Result)}CheckCSpace $Results完整代码，逻辑优化 针对并发逻辑，单独包成函数 不仅仅可以用来ping$AllComputers = Get-ADComputer -Filter * -SearchScope Subtree -SearchBase \"CN=Computers,DC=contoso,DC=com\"#region 函数与脚本块$ScriptBlock = { Param ( [string]$ComputerName ) function CheckIP ($ComputerName) { $sum = ping $ComputerName -w 100 -n 1 if ($sum -match \"TTL\") { $ComputerName Write-Host $ComputerName\"可通信\" -BackgroundColor Green } else { Write-Host $ComputerName\"不可通信，请检查\" -BackgroundColor Red } } CheckIP $ComputerName }#创建一个资源池，指定多少个runspace可以同时执行function CheckCSpace ($ComputerName) { Invoke-Command $ComputerName { $data = Get-PSDrive C $env:COMPUTERNAME + \",剩余空间 \" + [string]('{0:n1}' -f ($data.Free / 1GB)) + \" GB\" + \",剩余空间占比 \" + ('{0:n1}' -f ($data.Free / ($data.Used + $data.Free) * 100 ) + \"%\" ) }}function PSMultithreading ($Throttle, $allnodename, $ScriptBlock) { #线程，需要操作的对象，脚本块 $RunspacePool = [RunspaceFactory]::CreateRunspacePool(1, $Throttle) $RunspacePool.Open() $Jobs = @() $allnodename | ForEach-Object { $Job = [powershell]::Create().AddScript($ScriptBlock).AddArgument($_) $Job.RunspacePool = $RunspacePool $Jobs += New-Object PSObject -Property @{ Server = $_ Pipe = $Job Result = $Job.BeginInvoke() } } Write-Host \"请等待..\" -NoNewline Do { Write-Host \".\" -NoNewline Start-Sleep -Seconds 1 } While ( $Jobs.Result.IsCompleted -contains $false) Write-Host \"作业已完成\" -BackgroundColor Green $global:Results = @() ForEach ($Job in $Jobs) { $global:Results += $Job.Pipe.EndInvoke($Job.Result) } }#endregion 函数与脚本块PSMultithreading 100 $AllComputers.name $ScriptBlockCheckCSpace $Results遗留问题 针对ping不通的，如何进行展示。是忽略还是以其他方式表现。 使用并发逻辑之后，实际上可以在脚本块中同时完成检测和检查两个步骤。" }, { "title": "PowerShell修改Hyper-V虚拟机的UUID", "url": "/PowerShellModifyVMUUIDGUID/", "categories": "", "tags": "PowerShell进阶学习", "date": "2020-01-03 00:00:00 +0800", "snippet": "需求修改Hyper-V下，虚拟机的UUID，模拟更换主板导致的主机UUID的变更。实现有个叫做Eric Siron的大哥，很早已经做过这个事情的实现，所以完成这件事情是有现成脚本的。在2016年4月的时候，他发了一篇 PowerShell Script: Change the BIOS GUID of a Hyper-V Virtual Machine，这篇文章有现成脚本。在2017年4月的时候，他因为这个事情，写了一个集成工具Free Tool: Advanced Settings Editor for Hyper-V Virtual Machines大概是这个样子的。 这件事情给我的感触是，即使过去一年之久，你想要有改变，就一定有改变发生。另外他的这篇科普文Hyper-V Virtual CPUs Explained，Hyper-V虚拟机CPU的解释非常不错，浅入浅出，适合销售吹水。科普之二：为什么需要使用VMM、以及什么时候不使用WMI回归原题，这次修改虚拟机的UUID，实际是通过WMI来实现的。什么是WMI？ Windows管理规范（Windows Management Instrumentation，缩写WMI）由一系列对Windows Driver Model的扩展组成，它通过仪器组件提供信息和通知，并提供了一个操作系统的接口。WMI是微软对分布式管理工作组（DMTF）的基于Web的企业管理类（WBEM）和通用信息模型（CIM）标准的实现。 WMI预装在Windows 2000及更新版的微软操作系统中，适用于Windows NT、Windows 95和Windows 98等操作系统，[1][2]并允许使用脚本语言（例如VBScript或Windows PowerShell）来本地或远程管理Microsoft Windows个人电脑和服务器。 微软亦为WMI提供了一个称为Windows Management Instrumentation Command-line（WMIC）的命令行界面WMI在Windows 2000时代就有了，可以说是一个非常老的技术。但是为什么到2019，还会被反复用到，我觉得有这么几个原因 一些非常小众的功能，没有图形界面操作，有些人写过WMI实现，但是这些实现没有被更新到最新的操作系统中。 WMI更底层，即使有原生命令，但是用WMI效率可能会更好。当然我觉得大多数是第一个理由，一些稀奇古怪的需求（比如硬要修改UUID），消费者级别是很难接触到的，产品开发也不会去做，只留下了一个古老的WMI接口。WMI编辑器对于查看WMI属性，推荐一个WMI编辑器，没有之一注意，尽量用管理员方式打开，否则打开只能看到物理机信息，虚拟机看不到。而别的场景下，可能你看到的东西也是不全的。WMI查询与PowerShell代码有前辈已经写了一条范例,这条例子可以查看虚拟机的UUIDGet-VM \"VMname\" | % { (gwmi -Namespace root\\virtualization\\v2 -Class msvm_computersystem -Filter ('ElementName=\"{0}\"' -f $_.Name)).GetRelated('msvm_virtualsystemsettingdata') | select BIOSGUID }windows和linux的UUID稍有不同，主要是计算方式不一样Linux: A1B2C3D4-E5F6-G7H8-XXXX-XXXXXXXXXXXXWindows: D4C3B2A1-F6E5-H8G7-XXXX-XXXXXXXXXXXX其实UUID这个问题不仅困扰Hyper-V，对VMware一样心狠手辣，当然友商也有现成解决方法 这篇文章有非常详细的实现过程，可以看下讨论的过程。我们接下来先用WMI浏览器，根据上面的一些帖子，熟悉一下工具的使用。这里可以看到，我们能够很方便的查看WMI相关类的具体属性，以及它支持多少属性，有多少实例，你不需要用gwmi一遍一遍的查询，一次一次就可以搞定。最下方还可以帮你生成WQL的查询指令在这个位置，我们可以看到虚拟机名称和BIOSguid（也就是UUID），知道路径也就可以构造查询语句了。如果想查别的属性，也可以很方便的查看通过构造查询，才可以发现，这个鬼东西有多牛逼，它竟然可以把虚拟机快照的的BIOSguid抓出来（下图带日期的那条记录）比如说，我想修改BIOSguid，但是我不知道方法，用这个工具也能找到很合适的提示这里说明了，这个属性虽然是只读的，但是可以修改，根据提示搜索，找到了这里的详细说明，通过链接，能找到最原汁原味的C#方法：戳这里有了这些，就可以强硬构造PowerShell了。不过有前人写了那么的代码，找出核心部分重新构造即可。下面的代码用了一些现代的方法，比如点分表示法，管道查询。#这里假设虚拟机的VMname是2020$VMname=\"2020\"$vmx = Get-WmiObject -Namespace root\\virtualization\\v2 -Class msvm_virtualsystemsettingdata #每次操作选择一台虚拟机$CurrentSettingsData = $vmx | Where-Object { $_.ElementName -eq $VMname }#检查一下老的GUID$CurrentSettingsData.BIOSGUID#生成新GUID$GUID = [System.Guid]::NewGuid()#重新写入GUID，注意要带{}，这是非常重要的细节$CurrentSettingsData.BIOSGUID = \"{\" + $GUID.Guid.ToUpper() + \"}\" #生成一个ModifySystemSettings的空对象$VMMS = Get-WmiObject -Namespace root\\virtualization\\v2 -Class msvm_virtualsystemmanagementservice$ModifySystemSettingsParams = $VMMS.GetMethodParameters('ModifySystemSettings')#配置这个属性，需要特殊的转换方式$ModifySystemSettingsParams.SystemSettings = $CurrentSettingsData.GetText([System.Management.TextFormat]::CimDtd20)#写入$VMMS.InvokeMethod('ModifySystemSettings', $ModifySystemSettingsParams, $null) 总结温故而知新，永远不过时" }, { "title": "PowerShell从ASCII到字符的相互转换", "url": "/PowerShell_ASCII_to_Char/", "categories": "", "tags": "PowerShell进阶学习", "date": "2019-12-18 00:00:00 +0800", "snippet": "目标目标是生成一个数组，生成中华常用5000字，或者字母a到z，日语50音之类的。用途很多，比如大家来找茬，选出你曾经看到的字符，做验证码等等。其实a到z还好说，但是常用字或者生僻字这种字典就很麻烦了。基于这些字符在计算机中都是有序排列的，只要想办法顺序输出就可以了。原理.net有方法可以对ASCII码和真实字符之间做转换，网上找了个例子，翻译成PowerShell## 从一个数组转换为一个字符## 可以转换u3295 类似这种数据到真实的字符# 字符编码转换1，输出是一个数组 $enc = [system.Text.Encoding]::Unicode$string1 = \"鵢\" $data1 = $enc.GetBytes($string1) $data1# 从数组转换回字符$enc = [System.Text.Encoding]::Unicode$enc.GetString($data1)输出结果大概是这个样子的可用代码 针对代码转换来转换区，写两个函数就可以了 function GetCodePoint($ch) { #$retVal = \"u+\"; $bytes = ([system.Text.Encoding]::Unicode).getbytes($ch.ToString()) $global:bytex=$bytes for ($i = $bytes.length-1; $i -ge 0; $i--) { $retVal += ($bytes[$i]).ToString(\"X2\") } $retVal #[char][int](\"0x$retVal\") } function GetTrueChar ($retVal) {[char][int](\"0x$retVal\")} #跑个例子GetCodePoint 鵢GetTrueChar 9D62看起来没问题，转换正常 #一些小贴士 Characters如何使用PowerShell将ASCII值转换为字符？[char]64如何使用PowerShell将字符转换为ASCII值？[int][char]'@'如何使用PowerShell生成英文字母？[char[]](97..122)测试写一个生成一大堆乱七八糟字符的函数看看效果，因为ASCII，类似9D62这种实际是16进制数，最后转换成10进制数，然后进行转换。所以我们基于16进制或者直接10进制进行累加就能出来一大堆需要的数 $STARTx=GetCodePoint \"鵢\" Write-Host \"开始！\"1..100|%{#16进制首先转换成10进制，然后增加偏移量$_，再转换回16进制(字符大写) Write-Host (GetTrueChar ([System.Convert]::ToInt32($STARTx,16)+$_).ToString('X')) -NoNewline }用这种方法做出来的字典，非常优雅这个写法还有一个变种，可以用类似下面的方法，直接简单生成。 $日文部分字库 = 0..50 | ForEach-Object { [char][int](0x306e + (0x01 * $_)) }" }, { "title": "谁是注水猪，MiB与MB的区别", "url": "/WhoisZhushuiPigIncloud/", "categories": "", "tags": "PowerShell进阶学习", "date": "2019-12-13 00:00:00 +0800", "snippet": "多的一个i 现在很多云厂商的参考文献中，开始越来越多的对存储和流量的计算单位使用XiB,例如KiB，GiB。例如下面这种描述，这种描述有没有猫腻呢？Azure 订阅和服务限制、配额和约束条件一个小小的i,之所以产生这种差异，主要是历史原因，硬盘厂商计算存储使用1000进位，而计算机中则是1024(2的10次方)进位，在KB/GB/TB和KiB/GiB/TiB的转换中，每一级都要经受一次转换的损失。MiB和MB，KiB和KB等的区别:1KB(kilobyte)=1000byte, 1KiB(kibibyte)=1024byte1MB(megabyte)=1000000byte, 1MiB(mebibyte)=1048576byte所以12TB的硬盘只有10.91TiB，缩水的1T多就是这么来的。 但是按照现有计费方式，12T（TiB）的硬盘，实际要硬盘厂商制造一个13.19T（TB）的硬盘的，这多出来的肯定没人愿意买单计算范例Write-Host -BackgroundColor Green 实际1GB的字节数 $(1GB) -NoNewlineWrite-Host -BackgroundColor red $(1GB)Write-Host -BackgroundColor Green 按照1000进制计算，真实拥有1GiB，转换成GB的数量 -NoNewlineWrite-Host -BackgroundColor red $(1GB/1000/1000/1000)Write-Host -BackgroundColor Green 硬盘厂商眼中的1GB，实际的GiB大小 -NoNewlineWrite-Host -BackgroundColor red $(1000*1000*1000/1GB)云厂商的计算方式值得吐槽开心的是，至少三家A开头的云厂商都是使用注水猪没有i的计费方式。所以客户是不需要担心什么的，因为这很公平。但是如果客户查看了账单有疑问，你可能需要给客户解释一下，为什么多收了三五斗" }, { "title": "实现原样偷C#代码，在PowerShell中调用", "url": "/RealizetheoriginalstealC-codeCallinPowerShell/", "categories": "", "tags": "PowerShell进阶学习", "date": "2019-11-28 00:00:00 +0800", "snippet": "很早以前用过直接调用别人写好的DLL，直接在PowerShell中使用，知其然不知其所以然，为了防止以后忘记，这次做个详细记录。引子PowerShell不是万能的，但毕竟都是.Net家族的儿子，很多系统原生无法实现的功能（特别是图形编程，以及传统领域的操作），大部分都能在’C#’那找到合适的例子，所以或多或少算是有个解决方法。现在最大的挑战是，PowerShell毕竟出来这么多年，马上都要7.0了，因为方法的变更，C#代码在PowerShell中直接照抄，有时候会报错。为此还要去爬techet翻官方文档。所以即便是能抄C#代码，也不代表这是个简单的活，它至少需要两项能力 简单看懂C#，知道C#的操作方法和语法，还有一些作者的习惯性命令简写。 PowerShell要溜，因为要做一个C#到PowerShell的翻译。老实说，第二项是最操蛋的。毕竟是个翻译工作，之前也在如何更智能的看懂PowerShell的英文注释 中表述过类似的概念。DLL的优势DLL的优势是方法已经由作者写死了，用起来和模块一样，但是理论上，速度更快一些。这适合有些作者没有开源代码的情况来使用。而且成型的DLL，用起来真的是非常简单。像最常用的DLL，一个是汉字转拼音的微软官方DLL Microsoft Visual Studio International Pack 1.0 SR1，一个就是下面例子的QQ数据库了。 实现我的想法很简单，就是找到C#的例子后，如果代码相对很复杂，做C#到原生PowerShell的转换很麻烦的话，可以先用Visual Studio生成DLL，然后直接使用。首先还是学习了一下老司机的文章在.NET中的C# DLL文件的生成与使用照着大哥的方法实现了一遍，首先生成个项目，然后写入代码接下来正常的生成DLL，然后用下面的方法调用DLL关于这个模块中有哪些可以用的方法，在下拉菜单中可以看到。这是一个相对较复杂的代码，里面方法就很多了。这个时候查询，也能找到相应的方法。总结通过C#转DLL，然后PowerShell调用DLL的方法，极大的降低了从C#转换到PowerShell的难度。基本不需要对C#的阅读能力了。" }, { "title": "为Hyper-V虚拟机设置动态MAC的脚本", "url": "/SetDynamicMACScriptForHyper-VVrtualMachine/", "categories": "", "tags": "PowerShell进阶学习", "date": "2019-11-25 00:00:00 +0800", "snippet": "需求问题是这样的，手里有一波虚拟机，已经有MAC地址了，而且是静态的，但是某一天需要给他搬家，虚拟机所在的新家（VMM）限制了MAC地址段。所以需要给这些虚拟机先设置成动态MAC，让他们拿到新地址，然后再把新地址固化下来。实现手动操作就不说了，依然代码实现。老实说，我找了很久的代码。基本都是实现反向需求，就是给虚拟机设置静态MAC。但是我这不一样，我想设置成动态的啊。首先感谢这位大哥，大哥用了很传统的WMI开干，解决了问题。很可惜，PowerShell没有原生命令来解决这个问题#给虚拟机设置动态MAC的需求#只是针对单网卡操作，如果一个机器有多个网卡，逻辑不匹配function SetVMmacDyna ($vmName){ #Retrieve the Hyper-V Management Service, ComputerSystem class for the VM and the VM’s SettingData class. $Msvm_VirtualSystemManagementService = Get-WmiObject -Namespace root\\virtualization\\v2 ` -Class Msvm_VirtualSystemManagementService $Msvm_ComputerSystem = Get-WmiObject -Namespace root\\virtualization\\v2 ` -Class Msvm_ComputerSystem -Filter \"ElementName='$vmName'\" $Msvm_VirtualSystemSettingData = ($Msvm_ComputerSystem.GetRelated(\"Msvm_VirtualSystemSettingData\", ` \"Msvm_SettingsDefineState\", ` $null, ` $null, ` \"SettingData\", ` \"ManagedElement\", ` $false, $null) | ForEach-Object {$_}) #Retrieve the NetworkAdapterPortSettings Associated to the VM. #注意这里，中文系统和英文系统对网卡的命名是不一样的$Msvm_SyntheticEthernetPortSettingData = ($Msvm_VirtualSystemSettingData.GetRelated(` \"Msvm_SyntheticEthernetPortSettingData\") ` | Where-Object {$_.ElementName -eq \"网络适配器\"}) #网络适配器 #Network Adapter#Set the Static Mac Address To False and the Address to an Empty String$Msvm_SyntheticEthernetPortSettingData.StaticMacAddress = $false$Msvm_SyntheticEthernetPortSettingData.Address = \"\"$Msvm_VirtualSystemManagementService.ModifyResourceSettings($Msvm_SyntheticEthernetPortSettingData.GetText(2)) }#一把梭，设置完成(get-vm|Where-Object{$_.State -eq \"off\"}).name|ForEach-Object{SetVMmacDyna $_}" }, { "title": "快速剔除不存在的Active Directory域信息", "url": "/QuicklyWeedOutNonexistentADinformation/", "categories": "", "tags": "Active, Directory域进阶学习", "date": "2019-11-25 00:00:00 +0800", "snippet": "背景知识在给大型的Active Directory环境做架构升级、调整、扩容、还原等操作时，（比如30节点以上的环境），直接拿生产练手属于作死的行为。所以搭建POC环境很有必要。这篇文章是帮助大家解决在大型生产环境搭建Active Directory域POC时的一个繁琐步骤。处理流程按照传统做法，首先是备份环境中的任意一台Active Directory域控制器（最好是虚拟机），直接针对其导出快照镜像就可以了，然后在一个隔离网络的环境中进行测试就可以了。这里问题就来了，因为是一个独立的环境，我们也不可能把几十台Active Directory都倒腾出来，所以需要在这台服务器上，依次删除其他几十个服务器的关联关系。当删除到只剩一台的时候，才能开始测试。典型的处理一台主机的流程正常流程大概是下面这样的，需要使用命令行来处理C:\\Windows\\system32&gt;ntdsutilntdsutil: metadata cleanupmetadata cleanup: select operation targetselect operation target: connectionsserver connections: connect to server dc01.contoso.com绑定到 dc01.contoso.com ...用本登录的用户的凭证连接 dc01.contoso.com。server connections: quitselect operation target: list site找到 1 站点0 - CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=contoso,DC=comselect operation target: select site 0站点 - CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=contoso,DC=com没有当前域没有当前服务器当前的命名上下文select operation target: list domains找到 1 域0 - DC=contoso,DC=comselect operation target: select domain 0站点 - CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=contoso,DC=com域 - DC=contoso,DC=com没有当前服务器当前的命名上下文select operation target: list servers for domain in site找到 4 服务器0 - CN=DC01,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=contoso,DC=com1 - CN=TDC03,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=contoso,DC=com2 - CN=TDC04,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=contoso,DC=com3 - CN=TDC05,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=contoso,DC=comselect operation target:此处准备复制脚本问题来了这里的问题是，我们需要一个一个的去选择服务器，然后删除，然后退到上一层，然后再操作。这真的是很麻烦此时使用PowerShell生成一组命令，下方的1 .. 100 表示选择上面阶段找到的服务器，编号从1到100，这里需要根据实际需要选择，比如当前机器的编号是45，则脚本需要执行两次，一次是0-44，一次是46到100.cls1 .. 100 | %{\t$x = \"select server $_quitremove select serverselect operation target\"\t$x}脚本执行成功后，会在下方生成类似如下的文本字符，将文本字符拷贝出来，然后直接复制到上一阶段准备删除Active Directory环节的cmd中，系统就会连续执行，此时只需要鼠标点击确认即可。之所以脚本会连续执行，是因为……有回车。备注如果节点正常，一般使用如下方法进行角色迁移，仅作记录。正常使用transfercmdntdsutilrolesconnectionsconnect to server \"第二台DC的名稱\"quitseize rid masterseize pdcseize infrastructure masterseize domain naming masterseize schema master" }, { "title": "PowerShell处理IPMI的UEFI启动", "url": "/PowerShellhandlesUEFIStartupofIPMI/", "categories": "", "tags": "PowerShell进阶学习", "date": "2019-11-25 00:00:00 +0800", "snippet": "引子ipmitool.exe是一个非常棒的开源工具，没有之一。通过这个工具，我们可以很方便的批量修改服务器的属性，比如启动顺序，检查服务器上的磁盘、内存、硬件信息。我这里之前用到的一个功能是，用ipmi去修改服务器的启动顺序，调整为“下一次从PXE启动”。网上找的命令，XX机器很好用。但是XXXX就不好用，比如国产良心联想。问题原因经过分析，也很清晰了。主要是设置成PXE启动没问题，但是它是传统模式的PXE，而非UEFI的PXE。如果要是用UEFI模式的PXE，请看下面的例子。#支持UEFI引导的IPMI配置,使用IPMItools 1818$global:ipmiuser = \"USERID\" $global:ipmipass = \"PASSW0RD\"function ipmix($ip, $set) { $setx = \"-I lanplus -H \" + $ip + \" -U $global:ipmiuser -P $global:ipmipass \" + $set cmd /c \"ipmitool.exe $setx\"}我测试了好些例子，下面都是比较常用的例子。可以看到例子，实际上ipmitool并没有原生命令去处理这个问题，而是用RAW数据，硬往IPMI写数据实现的。所以我有个疑问，第一个发明这个解决问题方法的大哥，是怎么找到的呢？#检查主机是否开机ipmix $csv.ip[1] \"chassis status\"#设置目标主机的下一次启动为 UEFI模式的PXEipmix $csv.ip[1] \"raw 0x00 0x08 0x05 0xe0 0x04 0x00 0x00 0x00\"#清空目标主机下一次启动ipmix $csv.ip[1] \"chassis bootdev none\"#传统的设置下一次启动为PXE，如浪潮、H3Cipmix $csv.ip[1] \"chassis bootdev pxe\"#检查当前连接通道信息ipmix $csv.ip[1] \"channel info\"#检查硬件传感器ipmix $csv.ip[1] \"fru\"#检查内存传感器，可以确认内存插槽、温度ipmix $csv.ip[1] \"sdr type Memory\"#检查磁盘类设备ipmix $csv.ip[1] \"sdr type 'Drive Slot / Bay'\"#检查PCIE设备的插槽ipmix $csv.ip[1] \"sdr type 'Slot / Connector'\"ipmix $csv.ip[1] \"sel elist\"ipmix $csv.ip[1] \"sensor list\" #检查电源使用情况ipmix $csv.ip[1] \"dcmi power reading\"#检查DCMI可用选项ipmix $csv.ip[1] \"dcmi discover\"" }, { "title": "从VMM获取主机带外地址", "url": "/FromVMMgetIPMIaddress/", "categories": "", "tags": "PowerShell进阶学习", "date": "2019-11-25 00:00:00 +0800", "snippet": "需求在使用SCVMM的时候，需要统计一下哪些主机配置了带外管理地址，以及使用了这个带外管理地址的主机名字是啥。这其实是一个很简单的需求，问题只是在于这个带外的地址长的比较深它藏在.PhysicalMachine.BMCAddress下$date = date -Format MMddhhmmss$a = Get-SCVMHost | Sort-Object -Property nameWrite-Output \"name,BMC\" | Out-File (\"c:\\\" + $date + \"bmcaddress.csv\") -Force$a | ForEach-Object { Write-Host $_.name -NoNewline -ForegroundColor Red Write-Host $_.PhysicalMachine.BMCAddress -ForegroundColor Green Write-Output \"===\" $_.name + \",\" + $_.PhysicalMachine.BMCAddress | Out-File (\"c:\\\" + $date + \"bmcaddress.csv\") -Force -Append}notepad (\"c:\\\" + $date + \"bmcaddress.csv\") " }, { "title": "PowerShell保存剪贴板图片并构造MarkDown语句", "url": "/ExportPictureFromClipboardToMarkDown/", "categories": "", "tags": "PowerShell进阶学习", "date": "2019-11-07 00:00:00 +0800", "snippet": "目标最近在学着用MarkDown写文档，对传图片深恶痛绝。准备自己用PowerShell造个轮子，还好提前搜索，找到了很多大哥的文档。 整个要做的事情流程是 鼠标复制个剪贴板图片 进入程序处理逻辑 处理剪贴板图片，保存成本地文件（png或者jpg） 上传到一个图床，获取图床的连接 把图床的链接构造成MarkDown要求的格式，塞回剪贴板。 回到MarkDown编辑器，直接剪贴。 目标是2阶段的内容，完全用脚本实现。实现PowerShell对文件的操作进行创建修改是比较简单的，关键的地方在这里，用到了.net的方法直接去操作图片$img = [Windows.Clipboard]::GetImage()根据这个关键字，我们看一下Clipboard Class，里面有介绍到这个具体的方法GetImage()\t | Returns a BitmapSource object from the Clipboard that contains data in the Bitmap format.—|—这里不光可以get，还可以set，不光是图片，文字音频都可以操作，算是针对剪贴板的一整套方案都有了。原文输出的格式是PNG的，我想试试如何输出JPG图片刚才只是搞定了剪贴板的内容，接下来针对剪贴板数据，还需要保存成图片。代码这个可以学习下ImageCodecInfo.GetImageEncoders Method剪贴板保存PNG#剪贴板直接保存pngAdd-Type -Assembly PresentationCore$img = [Windows.Clipboard]::GetImage()if ($null -eq $img ) { Write-Host \"剪贴板无图\" Exit}$fcb = New-Object Windows.Media.Imaging.FormatConvertedBitmap($img, [Windows.Media.PixelFormats]::Rgb24, $null, 0)$filename = ((Get-Date -f s) -replace '[-T:]', '')$file = \"c:/img/{0}.jpg\" -f $filenameWrite-Host (\"`n 找到图片. {0}x{1} 像素，保存到{2}`n\" -f $img.PixelWidth, $img.PixelHeight, $file)$stream = [IO.File]::Open($file, \"OpenOrCreate\")$encoder = New-Object Windows.Media.Imaging.PngBitmapEncoder$encoder.Frames.Add([Windows.Media.Imaging.BitmapFrame]::Create($fcb))$encoder.Save($stream)# $stream.Dispose()各种花式，不局限于PowerShell{ Bitmap bmp1 = new Bitmap(typeof(Button), \"Button.bmp\"); bmp1.Save(@\"c:\\button.png\", ImageFormat.Png);}#相对简单存储图片#https://stackoverflow.com/questions/41665/bmp-to-jpg-png-in-c-sharp#高级存储图片#https://stackoverflow.com/questions/1484759/quality-of-a-saved-jpg-in-c-sharp#官方例子#https://docs.microsoft.com/en-us/dotnet/api/system.drawing.imaging.imagecodecinfo.getimageencoders?view=netframework-4.8PNG转换JPG这里用到了一个技巧，就是 Add-Type -AssemblyName system.drawing Add-Type -AssemblyName system.drawing $Source=“C:\\img\\tt2.png” $imageFormat = \"System.Drawing.Imaging.ImageFormat\" -as [type] $image = [drawing.image]::FromFile($Source) # 创建新图像 $NewImage = [System.Drawing.Bitmap]::new($Image.Width,$Image.Height) $NewImage.SetResolution($Image.HorizontalResolution,$Image.VerticalResolution) #根据新图像添加图形 $Graphics = [System.Drawing.Graphics]::FromImage($NewImage) $Graphics.Clear([System.Drawing.Color]::White) # Set the color to white $Graphics.DrawImageUnscaled($image,0,0) # Add the contents of $image #存储 $NewImage.Save(\"c:\\img\\vvv.jpg\",$imageFormat::Jpeg)读取一个IMG，调整大小，以及写入Add-Type -AssemblyName System.Drawing $img = New-Object System.Drawing.Bitmap(96, 96) ([System.Drawing.Graphics]::FromImage($img)).DrawImage([System.Drawing.Image]::FromFile((Get-Item C:\\img\\20191104135629.jpg)), 0, 0, 128, 128) $jpegCodecInfo = [System.Drawing.Imaging.ImageCodecInfo]::GetImageEncoders() | where {$_.MimeType -eq 'image/jpeg'} $encoderParams = New-Object System.Drawing.Imaging.EncoderParameters(1) $encoderParams.Param[0] = New-Object System.Drawing.Imaging.EncoderParameter([System.Drawing.Imaging.Encoder]::Quality, 90) $img.Save(\"c:\\img\\bouska2.jpg\", $jpegCodecInfo, $encoderParams) $img.Dispose() 用GIT给github传文件github是个不要钱的图床，它支持用git来上传下载文件。 配置本地git git config --global user.name \"用户名\"git config --global user.email \"用户邮箱\"cd ~/.sshssh-keygen -t rsa -C \"用户邮箱\"#上面这一步是生成一个证书，用来和github通信。 配置github接收密钥打开这里，在右侧菜单栏中找到SSH and GPG keys，选择new SSH key，输入title，下面key的内容就是本机ssh key,也就是刚才生成的公钥，直接将id_rsa.pub中的内容粘贴过来就可以，然后点击下面的add SSH key即可完成。 复制密钥输入这个命令cat id_rsa.pub，会出来类似下面的东西，复制出来，这就是密钥ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDRyubAWD7PfF+baIYAYVpdtTag7YZYdmCNz2mkoMjxkP6aN5C/Rnxxxxxxxxxxxxxxxxxxxxx5sSNV42co5S4Tc5W3eBB9bPBIoObqZ/g8JkCVrEIgUXTO1rn9p7h5erQ0/TcC/tIQ+HVxVx+mV7Y/wcYY05+Bbm8Cv60= a9y@live.cn 本地创建目录C:\\gitupdategit remote add origin https://github.com/kukisama/kukisama.github.io加个本地目录git add c:/gitupdate/picupdate/tt.txt上传本地文件git commit -m \"来个描述\" git push origin master拉回来git pull origin master上传前置条件准备的差不多了，可以看看完整代码。剪贴板直接保存png，然后传到github上，引用github page的地址#剪贴板直接保存pngAdd-Type -Assembly PresentationCore$img = [Windows.Clipboard]::GetImage()if ($null -eq $img ) { Write-Host \"剪贴板无图\"}$rootpath=\"C:/kukisama.github.io/picupdate/\"$fcb = New-Object Windows.Media.Imaging.FormatConvertedBitmap($img, [Windows.Media.PixelFormats]::Rgb24, $null, 0)$filename = ((Get-Date -f s) -replace '[-T:]', '')$file = \"$rootpath{0}.png\" -f $filenameWrite-Host (\"`n 找到图片. {0}x{1} 像素，保存到{2}`n\" -f $img.PixelWidth, $img.PixelHeight, $file)$stream = [IO.File]::Open($file, \"OpenOrCreate\")$encoder = New-Object Windows.Media.Imaging.PngBitmapEncoder$encoder.Frames.Add([Windows.Media.Imaging.BitmapFrame]::Create($fcb))$encoder.Save($stream)$stream.Dispose()$rootpath=\"C:/kukisama.github.io/picupdate/\"cd $rootpathcd ..$lastfile=(ls $rootpath |sort LastWriteTime -Descending)[0].name$MARKDOWNpic=New-Object System.Collections.ArrayList$MARKDOWNpic.add('![image](http://github.ny9s.com/picupdate/'+$lastfile+')')|out-null$MARKDOWNpic.Add(' ')|out-null$MARKDOWNpic|Set-ClipboardWrite-Host \"盆友，现在可以在MarkDown编辑器里面复制文本地址了\"git add $rootpath$lastfilegit commit -m $lastfilegit push -u origin master|Out-Null -ErrorAction SilentlyContinue#git rm -r C:/kukisama.github.io/picupdate/神转折功能逻辑基本算是完工了，但是突然我搜到这么一篇神帖看帖子的时间，2015年就已经有这逻辑了……………………这里有一个原生命令，Set-Clipboard 以及Get-Clipboard 所以保存文件只需要两步$PNGfile=Get-Clipboard -Format Image$PNGfile.Save($file)所以修改后的逻辑是这样的$PNGfile=Get-Clipboard -Format Imageif ($PNGfile){$rootpath=\"C:/kukisama.github.io/picupdate/\"$internetURL=\"http://github.ny9s.com/picupdate/\"$filename = ((Get-Date -f s) -replace '[-T:]', '')$file = \"$rootpath{0}.png\" -f $filename$PNGfile.Save($file)cd $rootpath;cd ..$MARKDOWNpic=New-Object System.Collections.ArrayList#$MARKDOWNpic.add('![image]('+$interneturl+$filename+'.png'+')')#上面这个地址是github page的地址，但是实际来看，这个地址刷新的速度很慢，所以我直接取了文件的时间地址$MARKDOWNpic.add('![image]('+'https://github.com/kukisama/kukisama.github.io/blob/master/picupdate/'+$filename+'.png'+'?raw=true)')$MARKDOWNpic.Add(' ')$MARKDOWNpic|Set-ClipboardWrite-Host \"盆友，现在可以在MarkDown编辑器里面复制文本地址了\"git add $file git commit -m $filename git push }小技巧还收获了一个小技巧：针对对象输出的屏幕字符，可以先转换成字符串，然后输出到剪贴板dir | Out-String | Set-Clipboard 使用FTP上传github page的图床真的是不能明着说，反正国内就是不稳定。这里初步想法是使用最妥的FTP来完成图片的保存工作，自己架设一个FTP服务器，假设名字是 xxx.ny9s.com 实际对应web站点 ny9s.com/pic 实际要做的就是把图片传到FTP，然后生成对应的web端的字符串。 再次修改下脚本。先照着Ubuntu16.04安装ftp服务器去配置一下sudo apt-get install vsftpd创建用户目录 sudo mkdir picupdate创建用户 sudo useradd -d /var/www/html/picupdate -s /bin/bash uftpsudo mkdir picupdatesudo vi /etc/vsftpd.conf#编辑vsftpd.conf文件userlist_deny=NOuserlist_enable=YES#允许登录的用户userlist_file=/etc/allowed_usersseccomp_sandbox=NO#默认ftp下载目录local_root=/home/uftp/local_enable=YES#设置文件上传write_enable=YES#使用utf8utf8_filesystem=YES添加允许登录的用户sudo gedit /etc/allowed_users修改完之后保存，然后可以重启服务sudo /etc/init.d/vsftpd startsudo /etc/init.d/vsftpd stopsudo /etc/init.d/vsftpd restart 如果是开被动模式的花，打开xxx/vsftpd/vsftpd.conf，在末尾添加:pasv_enable=YES //开启PASV模式pasv_min_port=40000 //最小端口号pasv_max_port=40000 //最大端口号pasv_promiscuous=YES再配置下权限sudo chown uftp:uftp /var/www/html/picupdate/FTP上传文件逻辑# create the FtpWebRequest and configure it$ftp = [System.Net.FtpWebRequest]::Create(\"ftp://localhost/me.png\")$ftp = [System.Net.FtpWebRequest]$ftp$ftp.Method = [System.Net.WebRequestMethods+Ftp]::UploadFile$ftp.Credentials = new-object System.Net.NetworkCredential(\"anonymous\",\"anonymous@localhost\")$ftp.UseBinary = $true$ftp.UsePassive = $true# read in the file to upload as a byte array$content = [System.IO.File]::ReadAllBytes(\"C:\\me.png\")$ftp.ContentLength = $content.Length# get the request stream, and write the bytes into it$rs = $ftp.GetRequestStream()$rs.Write($content, 0, $content.Length)# be sure to clean up after ourselves$rs.Close()$rs.Dispose()sudo vi /etc/vsftpd.confsudo vi /etc/servicessudo /etc/init.d/vsftpd restartvsftpd启动后，默认的ftp端口是21，现在我想把ftp端口改成 801 ,修改后能保证用户上传下载不受影响1.编辑 /etc/vsftpd/vsftpd.conf 文件，在该配置文件中添加此行：listen_port=8012.编辑 /etc/services 文件，将其中的 ftp 21/tcp 改为 ftp 801/tcp ftp 21/udp改为 ftp 801/udp3.执行 /etc/init.d/vsftpd restart 重新启动 vsftpd 服务。启动完成后可以使用 netstat -ntpl | grep vsftpd 命令可以查看到系统现监听的 vsftpd 的端口为 8014.使用 lftp 192.168.0.1:801(192.168.0.1 是 vsftpd 服务器的地址 )，这样就可以访问到 ftp 服务器了。开启防火墙ufw enable关闭防火墙ufw disable然而上面的问题虽然看起来步骤应该很详细了，但是问题是在我的环境配置失败了……Posh SSH花了很多时间在FTP上，开始继续寻找解决方案。经过测试，最简单的方法是安装Posh-SSH模块，用SSH的方式去上传下载文件。这个模块在github可以下载到。另外也可以使用Install-Module -Name Posh-SSH -RequiredVersion 2.0.2直接安装，我觉得优点如下： 服务器只需要开SSH端口，而且这个端口可以不用22，映射成其他端口一样工作正常。 不用像FTP一样配主动被动模式，配账户，开端口改端口什么的 文件整体不大，才2M多，删除帮助文件之后才1.7M，不管是直接下载还是弄成离线包都可以实现。4.大哥的代码封装的很出色了，上传下载文件只需要一条命令。自己写也差不多这样就是极限了。代码范例$cred=Get-Credential #同意KEY，从远程下载文件Get-SCPFile -ComputerName \"ny9s.com\" -Port 12121 -Credential $cred -RemoteFile \"/home/kukisama/IOid.jpg\" -LocalFile 'C:\\img\\ppp.jpg' -AcceptKey#上传 Set-SCPFile -ComputerName \"ny9s.com\" -Port 12121 -Credential $cred -Remotepath \"/home/kukisama\" -LocalFile 'C:\\img\\ppp.jpg'模块可清理的内容如果是在线安装的话，模块会位于C:\\Program Files\\WindowsPowerShell\\Modules\\Posh-SSH如果不要了，直接删除就相当于卸载。整体目录有2.26MB，有500K的帮助文件，测试后，发现删除没影响（en-US目录)。密码加解密逻辑为了静默连接SSH，所以用到一个密码逻辑，它可将所需要用到的$cred加密放在本地文件夹中，使用的时候会比较简单#步骤1、将密码加密后保持到c:\\xxx.txt。$mysecret=\"xxxxxx\" #此处放密码$mysecret|ConvertTo-SecureString -AsPlainText -Force |ConvertFrom-SecureString|Out-File C:\\picupdate\\pass.txt -Encoding utf8#步骤2、将密文密码转换成powershell可以使用的格式$securestring=(Get-Content C:\\picupdate\\pass.txt).ToString() | ConvertTo-SecureString$ptr = [System.Runtime.InteropServices.Marshal]::SecureStringToGlobalAllocUnicode($secureString)$serverpass = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($ptr) $Password = ConvertTo-SecureString $serverpass -AsPlainText –Force#步骤3、使用$UserName = \"admin\" #定义管理员账户名称$cred = New-Object System.Management.Automation.PSCredential($UserName,$Password) 整体代码，PNG格式$PNGfile=Get-Clipboard -Format Imageif ($PNGfile){$rootpath=\"C:/picupdate/\"$internetURL=\"http://ny9s.com/picupdate/\"$filename = ((Get-Date -f s) -replace '[-T:]', '')$file = \"$rootpath{0}.png\" -f $filename$PNGfile.Save($file)cd $rootpath $MARKDOWNpic=New-Object System.Collections.ArrayList$MARKDOWNpic.add('![image]('+$internetURL+$filename+'.png)')$MARKDOWNpic.Add(' ')$MARKDOWNpic|Set-ClipboardWrite-Host \"盆友，现在可以在MarkDown编辑器里面复制文本地址了\"Import-Module D:\\Posh-SSH\\Posh-SSH.psd1 #注意模块，我这里是没有安装到系统中使用的$securestring=(Get-Content C:\\picupdate\\pass.txt).ToString() | ConvertTo-SecureString$ptr = [System.Runtime.InteropServices.Marshal]::SecureStringToGlobalAllocUnicode($secureString)$serverpass = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($ptr) $Password = ConvertTo-SecureString $serverpass -AsPlainText –Force$UserName = \"kukisama\" #定义管理员账户名称$cred = New-Object System.Management.Automation.PSCredential($UserName,$Password) #上传Set-SCPFile -ComputerName \"ny9s.com\" -Port 8888 -Credential $cred -Remotepath \"/var/www/html/picupdate\" -LocalFile $($rootpath+$filename+'.png') }可优化项考虑到图片上传怎么样都需要个几秒钟，所以逻辑上可以先生成MarkDown所需要的字符串，然后定期去上传，比如一分钟或者十分钟一次。这样体验上会好一些。当然，上传完毕也要做一些标志位的检测，比如上传成功后，再也不会上传，记录上传时间，消耗时间什么的" }, { "title": "如何更智能的看懂PowerShell的英文注释", "url": "/TransitPowershellCodeUseMicrosoft/", "categories": "", "tags": "PowerShell进阶学习", "date": "2019-10-31 00:00:00 +0800", "snippet": "引言无论是什么语言的代码，合理的注释以及手册都是交付的必要条件。经过上一个章节，相信大家可以明白给变量命名的重要性。现在新的问题来了： 存在语言障碍的情况下，怎么去读懂别人的代码，或者说，更明白的看懂注释。学外语我从不掩盖自己屎一样的外语。从多年工作来说，外语薄弱会有很多影响，但对编程的影响不是致命的。翻译现在机器翻译已经做到相对足够好，比如下面这家公司的产品 Microsoft 文本翻译 API 是一项基于云的机器翻译服务，支持多种语言，其支持的语言覆盖全球国内生产总值 (GDP) 95% 以上的区域。使用 Translator 可构建应用程序、网站、工具或任何需要多语言支持的解决方案。它提供有免费的API接口，每个月可以免费用200万字。更贵的套餐也有，比如我现在用的 ` S1套餐，$40/百万 个字符的自定义翻译`API在使用它之前，需要先注册一个账号，具体的操作方法可以在官方网站的快速入门查找，很简单。接下来我们需要看一下他的API比较可惜也是情理之中的事情是，并没有PowerShell相关的范例代码。根据这个范例，以及C#大哥的参考。下面来构造PowerShell（.net家族小弟）的查询代码 首先是两个核心函数，通过这个函数，朋友们可以学习下关于WEB请求部分，C#代码是如何翻译成PowerShell。 获取所有支持的语言版本 翻译 function GetAllTranslatorLang {\t((Invoke-WebRequest https://api.cognitive.microsofttranslator.com/languages?api-version=3.0).Content | ConvertFrom-Json).translation}function translatorMS ($language, $texts) {\t$APIuri = \"https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&amp;to=$language\" #&amp;from=zh-Hans\t$translatordata = Invoke-WebRequest $APIuri ` -Body $texts -ContentType \"application/json;charset=utf-8\" -Method POST -Headers $postParams\t($translatordata.Content | ConvertFrom-Json).translations.text} 注意用到的KEY，这个要提前申请，$subscriptionKey = '这里是key'$postParams = @{ \"Ocp-Apim-Subscription-Key\" = \"$subscriptionKey\" }#然后这么使用函数就可了translatorMS -language $lanx -texts $body是不是很简单？通过上满几行，我们举一反三，就可以写出如下完整代码.用法也很简单 把下面的代码里面的KEY换成自己申请的， 然后代码存储为.ps1 想办法把它转换成exe 最后将需要翻译的ps1文件，拖动到这个文件上,默认情况下支持中英互转 如果你不在步骤2转换为exe，则需要使用类似如下的方法来使用 &amp; '.\\Bing Transit 0.1.ps1' -filename C:\\x\\azaa.ps1 -languages \"zh-Hans\" 最终结果：自动生成一个同名目录，里面有翻译好注释的ps1文件，以及所有抽出来的注释代码param ($filename,\t$languages = @(\"zh-Hans\", \"en\"))#param ($filename,$languages = @(\"zh-Hans\", \"ja\", \"en\", \"ko\"))#region functionfunction CreateNewFolder ($NewFolder) {\tif (!(Test-Path $NewFolder)) {\t\tmkdir $NewFolder | Out-Null\t}}function GetAllTranslatorLang {\t((Invoke-WebRequest https://api.cognitive.microsofttranslator.com/languages?api-version=3.0).Content | ConvertFrom-Json).translation}function translatorMS ($language, $texts) {\t$APIuri = \"https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&amp;to=$language\" #&amp;from=zh-Hans\t$translatordata = Invoke-WebRequest $APIuri ` -Body $texts -ContentType \"application/json;charset=utf-8\" -Method POST -Headers $postParams\t($translatordata.Content | ConvertFrom-Json).translations.text}function ConvertLanguage ($comments) {\tfor ($i = 0; $i -lt $comments.count; $i++) {\t\t$x = $comments[$i].split(',')\t\tif ($x[1] -match \"region\" -or $x[1] -match \"\\A#&gt;\" -or $x[1] -match \"=\" -or $x[1] -match \"\\$\") {\t\t\t$comments[$i]\t\t}\t\telse { $x[0] + \",#\" + $translatored[$i] }\t}}#endregion function#$filename = \"C:\\x\\ConvergedDeploy-V1.1.ps1\"$subscriptionKey = '这里是KEY'$postParams = @{ \"Ocp-Apim-Subscription-Key\" = \"$subscriptionKey\" }$gcfile = Get-Content $filename -Encoding UTF8$info = New-Object System.Collections.ArrayList$info2 = New-Object System.Collections.ArrayList$fileNewname = $filename.Split('\\')[-1].Substring(0, $filename.Split('\\')[-1].Length - 4)$NewFolder = ($filename.Split('\\')[0 .. ($filename.Split('\\').count - 2)] -join \"\\\") + \"\\\" + $fileNewname + \"\\\"CreateNewFolder $NewFolder#创建原始文件、提取的描述文件、创建删除所有注释的文件for ($i = 0; $i -lt $gcfile.count; $i++) {\tif ($gcfile[$i].Trim() -match \"\\A#.*\") {\t\t$info2.Add([string]$i + \",\" + $gcfile[$i].Trim()) | Out-Null\t}\telseif ($gcfile[$i].Trim() -eq \"\") { } #删除所有空行，可选\telse {\t\t$info.Add($gcfile[$i]) | Out-Null\t}}$gcfile | Set-Content $NewFolder$fileNewname\".orgin.ps1\" -Force -Encoding utf8$info | Set-Content $NewFolder$fileNewname\".Production.ps1\" -Force -Encoding utf8$info2 | Set-Content $NewFolder$fileNewname\".comments.txt\" -Force -Encoding utf8############翻译，根据comments写回注释$filename = $NewFolder + $fileNewname + \".orgin.ps1\"$fileNewname = $filename.Split('\\')[-1].Substring(0, $filename.Split('\\')[-1].Length - 10)$orginfile = Get-Content $filename -Encoding UTF8#获取所有支持的语言GetAllTranslatorLangGet-ChildItem $NewFolder *.transedcomments.* | Remove-Item#获取原始文件的注释$comments = Get-Content $NewFolder$fileNewname\".comments.txt\" -Encoding utf8#50一组，分割一下$commentslengthcount = [math]::ceiling($comments.count / 50)for ($i2 = 1; $i2 -le $commentslengthcount; $i2++) {\tif ($i2 -ne $commentslengthcount) {\t\t$ctx = $comments[(0 + $i2 * 50 - 50) .. ($i2 * 50 - 1)]\t}\telse {\t\t$ctx = $comments[(0 + $i2 * 50 - 50) .. ($comments.Count - 1)]\t}\t\t$body = $ctx | ForEach-Object { $_ | Select-Object @{ name = 'text'; e = { $_.split(',')[-1].replace('#', '') } } } | ConvertTo-Json\t\t$languages | ForEach-Object {\t\t$lanx = $_\t\t$translatored = translatorMS -language $lanx -texts $body\t\t$commentsnew = ConvertLanguage $ctx\t\t#带有行号的翻译\t\t$commentsnew | Add-Content $NewFolder$fileNewname\".\"$lanx\".transedcomments.txt\"\t}}$languages | ForEach-Object {\t$lanx = $_\t$info3 = New-Object System.Collections.ArrayList\t$y = 0\t$commentsnew = Get-Content $NewFolder$fileNewname\".\"$lanx\".transedcomments.txt\"\tfor ($i = 0; $i -lt $orginfile.count + 1; $i++) {\t\tif ($commentsnew[$y] -ne $null) {\t\t\t$commentscount = $commentsnew[$y].split(',')[0]\t\t}\t\telse { $commentscount = \"\" }\t\t\t\tif ($i -eq $commentscount) {\t\t\t$info3.Add($commentsnew[$y].split(',')[1]) | Out-Null\t\t\t$y++\t\t}\t\telse {\t\t\t$info3.Add($orginfile[$i]) | Out-Null\t\t}\t}\t$info3 | Set-Content $NewFolder$fileNewname\".\"$lanx\".ps1\" -Force}0,##处理SMB网络的路由，检查网络配置，每个网络的特征5,#region prep6,#$ErrorActionPreference = \"Stop\"7,#####手动属性13,#####自动属性21,#$csvPath = \"$rootpath\\hfpd01new.csv\"22,#endregion prep24,#region x25,#Get-Help about_ActiveDirectory_Filter26,#刷新组策略34,# VMM添加运行方式账户44,# 创建端口分类46,# 根据端口分类，创建端口配置文件50,# 创建VM主机组53,# 创建管理和存储逻辑网络，存储为SMB网络57,#创建地址池0,#SMB ネットワークのルーティングの処理、ネットワーク構成の確認、各ネットワークの特性5,#region prep6,#$ErrorActionPreference = \"Stop\"7,#手動プロパティ13,#自動プロパティ21,#$csvPath = \"$rootpath\\hfpd01new.csv\"22,#endregion prep24,#region x25,#ActiveDirectory_Filter に関するヘルプの取得26,#グループ ポリシーの更新34,# VMM 実行アカウントの追加44,# ポート分類の作成46,# ポートの分類に基づいてポート プロファイルを作成する50,# VM ホスト グループの作成53,# SMB ネットワークとして格納される管理およびストレージ論理ネットワークの作成57,#アドレス プールの作成未解决的问题因为大部分场景已经满足了我自己的需求，比如判断注释里面有没有$,=这些本身有特定含义的行不去翻译。所以还剩下有问题的，都是一些 很简单 难搞的部分，比如 无法处理&lt;# #&gt;包裹的注释 无法处理一行代码写完之后不换行，在最后写#然后注释。如果后面有空，我会继续改进的用翻译软件是大势所趋，无论是自用还是要走国际范，让代码走出国门，Microsoft 文本翻译 API都是您的明智之选" }, { "title": "如何编写完全无法维护的powershell脚本", "url": "/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%AE%8C%E5%85%A8%E6%97%A0%E6%B3%95%E7%BB%B4%E6%8A%A4%E7%9A%84PowerShell%E8%84%9A%E6%9C%AC/", "categories": "", "tags": "", "date": "2019-10-29 00:00:00 +0800", "snippet": "说起无法维护的代码，相信朋友们有很多的想法，比如说没有注释、屎一样的逻辑、通篇重复代码但是下面这个方法一定是最彻底最让你绝望的。方法朋友们一定会对变量的命名下很多心思，如果不认真对待变量名，后果是致命的。下面是把一个现有的ps1文件，简单的转换成作死代码。$gcfile = Get-Content \"C:\\x\\azaa.ps1\"$xyz = ($gcfile -match \"^\\$.*=?\" | ForEach-Object { $_.split(' |%|+|=')[0] } | Select-Object -Unique )$xyz | Sort-Object -Property length -Descending$字母小写 = 0..25 | ForEach-Object { [char][int](0x0061 + (0x01 * $_)) }$日文 = 0..50 | ForEach-Object { [char][int](0x306e + (0x01 * $_)) }$字库=$日文0..$($xyz.count - 1) | ForEach-Object { $改造变量名 = \"$\" 1..8 | ForEach-Object { $改造变量名 += Get-Random $字库 } $gcfile = $gcfile.replace($xyz[$_], $改造变量名)}$gcfile我们来看看原文$postParams = @{\"Ocp-Apim-Subscription-Key\" = \"$subscriptionKey\" }$comments = Get-Content $NewFolder$fileNewname\".comments.txt\" -Encoding utf8$body = $comments | % { $_ | Select-Object @{name = 'text'; e = { $_.split(',')[-1].replace('#', '') } } } | ConvertTo-Json$languages|%{$lanx=$_ if ($i -eq $commentscount) { $info3.Add($commentsnew[$y].split(',')[1]) | Out-Null $y++ } else { $info3.Add($orginfile[$i]) | Out-Null }}$info3 | Set-Content $NewFolder$fileNewname\".\"$lanx\".ps1\" -Force}加工后的代码$みぶ゗をわやべ゙ = @{\"Ocp-Apim-Subscription-Key\" = \"$るゐを゙ぱゕゕの\" }$んゃゅるぽらゃほ = Get-Content $りぽわめる゗れ゗$めゆびわゃふみぱ\".comments.txt\" -Encoding utf8$ろゑらぴぶゎやひ = $んゃゅるぽらゃほ | % { $_ | Select-Object @{name = 'text'; e = { $_.split(',')[-1].replace('#', '') } } } | ConvertTo-Json$まみゎわゕゞぷゎ|%{$むゐへやゅゎるゟ=$_$ぽ゚ぷ゜ぱも゠ぽ = translatorMS -language $むゐへやゅゎるゟ -texts $ろゑらぴぶゎやひ$んゃゅるぽらゃほnew = ConvertLanguage $ひへぱび゗゙のゆ3.Add($んゃゅるぽらゃほnew[$ゐりへゟゃ゛ゎを].split(',')[1]) | Out-Null $ゐりへゟゃ゛ゎを++ } else { $ひへぱび゗゙のゆ3.Add($びほゎばべゕび゙[$i]) | Out-Null }}$ひへぱび゗゙のゆ3 | Set-Content $りぽわめる゗れ゗$めゆびわゃふみぱ\".\"$むゐへやゅゎるゟ\".ps1\" -Force}当然这是随机的，所以每次输出都可以不一样，英韩俄印总有一款适合你$ゃ゙ぼぷれゃぶも = @{\"Ocp-Apim-Subscription-Key\" = \"$ょべゆら゠べゃみ\" }$ぽめ゚ゐをれまゔ = Get-Content $ゅぺんぴばひひゃ$ゃや゘をんびはぺ\".comments.txt\" -Encoding utf8$ぶぶわやゔゑめ゜ = $ぽめ゚ゐをれまゔ | % { $_ | Select-Object @{name = 'text'; e = { $_.split(',')[-1].replace('#', '') } } } | ConvertTo-Json$ゆゐばみゃゐのの|%{$ばゔをゔゝょゎら=$_$ゖ゗ふぺゃゑまり = translatorMS -language $ばゔをゔゝょゎら -texts $ぶぶわやゔゑめ゜ else { $やゝもわぱ゜ゃば3.Add($べみ゠ぷまゖょび[$i]) | Out-Null }}$やゝもわぱ゜ゃば3 | Set-Content $ゅぺんぴばひひゃ$ゃや゘をんびはぺ\".\"$ばゔをゔゝょゎら\".ps1\" -Force}老实说，作为这段代码的亲身父亲，我已经放弃跟他相认。如果有下一回合的话，我们会介绍一下为什么要这么做，以及这篇文章中用到的一些有用技术点。" }, { "title": "不用telnet，powershell快速ping端口", "url": "/%E4%B8%8D%E7%94%A8Telnet-PowerShell%E5%BF%AB%E9%80%9Fping%E7%AB%AF%E5%8F%A3/", "categories": "", "tags": "", "date": "2019-10-24 00:00:00 +0800", "snippet": "在Windows中，测试一个目标地址的端口是否通断，常用办法是使用telnet。但是这工具的问题在于不随系统安装，且对端目标端口失败的时候，超时时间很长#找到一个大佬分享的方法$address = \"192.168.1.10\"$port = 80$tcp = new-object Net.Sockets.TcpClient$tcp.Connect($address,$port)If ($? -ne \"True\") {Write-Host $address\"的端口\"$port\"连接失败\"}Else {$tcp.Close()}#原作者#https://blog.51cto.com/beanxyz/1784596 这里有个问题就是，如果连接失败，超时时间特别长，而且会有红色报错，根据关键字Net.Sockets.TcpClient继续查找资料 去官方网站看看这个方法https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.tcpclient?view=netframework-4.8 这里介绍的很详细，不过主要问题是可以使用的方法太多，不知道用哪一个。在Stackoverflow找到最合适的一个例子这里#原C#逻辑bool IsPortOpen(string host, int port, TimeSpan timeout){ try { using(var client = new TcpClient()) { var result = client.BeginConnect(host, port, null, null); var success = result.AsyncWaitHandle.WaitOne(timeout);###下文省略翻译一下，变成我们PowerShell的写法，问题解决，还可以设置超时时间，速度非常快$tcp = new-object Net.Sockets.TcpClient$result = $tcp.BeginConnect(\"baidu.com\", \"80\", $null,$null)$result.AsyncWaitHandle.WaitOne(200)$tcp.Close()" }, { "title": "Ad时间同步，需要配置多时间源的环境", "url": "/AD%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5-%E9%9C%80%E8%A6%81%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%97%B6%E9%97%B4%E6%BA%90%E7%9A%84%E7%8E%AF%E5%A2%83/", "categories": "", "tags": "", "date": "2019-10-24 00:00:00 +0800", "snippet": "针对AD中配置时间源，方法基本是固定的打开命令行模式，执行以下命令:w32tm /config /manualpeerlist:timeserver /syncfromflags:manual /reliable:yes /update （其中：timeserver设置为 xxx.xx.xx.xx）然后, 重启 W32Time 服务.验证时间服务器是否可用，可以使用以下方法，在命令行模式下执行：w32tm /resync /computer:target----与设置好的时间服务器执行同步，target设置为时间服务器地址w32tm /stripchart /computer:target-----查看与时间服务器的时间差适用于多IP地址情况#官方参数说明连接manualpeerlist：&lt;peers&gt; -将手动对等列表设置为&lt;peers&gt;，这是一个以空格分隔的域名系统（DNS）和/或IP地址列表。当您指定多个对等方时，此选项必须用引号（“）引起来。syncfromflags：&lt;源&gt; -设置NTP客户端应从哪些源进行同步。&lt;source&gt;应该是这些关键字的逗号分隔列表（不区分大小写）：手动 —包括手动对等方列表中的对等方。DOMHIER —从域层次结构中的域控制器同步。否 -不从任何服务器同步。ALL-从手动和域对等方同步。针对多时间源的时间同步配置方法#地址用空格隔开，然后注意有引号w32tm /config /manualpeerlist:\"1.1.1.1 2.2.2.2 3.3.3.3 /syncfromflags:manual /reliable:yes /update " }, { "title": "解决scvmm与sofs配置共享权限failed to set security info", "url": "/%E8%A7%A3%E5%86%B3SCVMM%E4%B8%8ESOFS%E9%85%8D%E7%BD%AE%E5%85%B1%E4%BA%AB%E6%9D%83%E9%99%90Failed-to-set-security-info/", "categories": "", "tags": "", "date": "2019-09-25 00:00:00 +0800", "snippet": "症状因为将一组群集，多次在VMM中进行添加删除的维护。多次操作之后，我发现群集在VMM中无法创建SOFS的共享卷，其他表现正常。错误0 错误(26561)在存储池 S2D on HFPD01STOR01 上创建卷 Share576855D2 失败，错误代码为 4 [SM_RC_GENERIC_FAILURE]。Cannot convert ‘System.Object[]’ to the type ‘Microsoft.Management.Infrastructure.CimInstance’ required by parameter ‘InputObject’. Specified method is not supported. 建议的操作请指定用于创建卷的有效参数。错误1 错误(12700)由于以下错误，VMM 无法在“主机名”服务器上完成主机操作: Storage migration for virtual machine ‘fghyju8989’ (EC699F08-CCBE-45C0-B7E8-DB4D319E7A29) failed with error ‘General access denied error’ (0x80070005). Failed to set security info for ‘\\主机名\\VMSTOR14\\XXXX\\fghyju8989’: ‘General access denied error’(‘0x80070005’).Unknown error (0x8001) 建议的操作请解决此主机问题，然后重试该操作针对错误0，怀疑’Microsoft.Management.Infrastructure.CimInstance’这句是根本原因。但是经过很多尝试，包括重建群集，重建S2D，依然无法解决这个问题。因此转向手动创建所需的SOFS共享，并由VMM接管处理流程处理过程使用如下命令#创建一个到目标群集的cismsession$newsession=New-CimSession 目标群集名称#在群集新创建一个3路镜像卷，New-Volume -CimSession $newsession -FriendlyName \"test02\" `-FileSystem CSVFS_ReFS -StoragePoolFriendlyName S2D* -Size 3GB -ResiliencySettingName Mirror #针对群集配置权限New-SmbShare -CimSession $newsession -Name \"test02\" `-Path \"C:\\ClusterStorage\\test02\\\" -FullAccess \"域名\\账号\", \"域名\\计算机名$\"到这里出现了新的问题，创建的目录可以在VMM中刷新出来，也可以使用如下代码，在VMM中接管#FS1所有共享$FileShare = Get-SCStorageFileShare |?{$_.StorageFileServer -match \"SOFS名称\"}#存储文件服务器 $FileServer = Get-SCStorageFileServer \"SOFS的FQDN\"Set-SCStorageFileServer -StorageFileServer $FileServer -AddStorageFileShareToManagement $FileShare 但是，目录只能正常配置”共享权限”,不能配置”安全权限”,而且最严重的是，创建出来的共享目录，虚拟机不能迁移，例如在群集1的磁盘1到磁盘2迁移，或者群集1到群集2迁移。基本属于不可用状态。输入常规的配置命令，系统会显示配置成功，但实际不会生效。例如Grant-SmbShareAccess -CimSession $newsession -Name $_ -AccountName \"$($env:USERDOMAIN)\\Storage Server Admins\" -AccessRight Full -Confirm:$false Grant-FileShareAccess -CimSession $newsession -Name $_ -AccountName \"$($env:USERDOMAIN)\\common share users\" -AccessRight Full -Confirm:$false 以及get-acl \\\\群集服务器地址\\VMSTOR12 | fl$aclobj=get-acl \\\\群集服务器地址\\VMSTOR14 set-acl \\\\需要配置的群集服务器地址\\VMSTOR111 -AclObject $aclobj还有takeown /F \\\\群集服务器地址\\VMSTOR04 /A /R /D Ytakeown /f * /a /r /d y这些都不行，效果都一样。icacls \\\\群集服务器地址\\VMSTOR04 /setowner \"域名\\omadmin\" #/T /C测试了两天，还是没有找到原因。解决经过仔细检查，发现通过SOFS创建的目录，大致是这样的 C:\\ClusterStorage\\Share0BAD227D\\Shares\\VMSTOR01 目录结构：存储空间→创建一个随机名的卷Share0BAD227D，在卷下创建Shares目录，在Shares目录下创建VMSTOR01而自己手动用命令创建的是这样的 C:\\ClusterStorage\\VMSTOR01&gt; 目录结构：存储空间→创建一个固定命名的卷VMSTOR01这两者的区别在于，VMM的做法是在卷上创建了文件夹，基于文件夹定义权限。所以目标是改成下面这种形式，测试一下。 C:\\ClusterStorage\\VMSTOR01\\share&gt;关键代码如下New-Item C:\\ClusterStorage\\$xname\\share -ItemType DirectoryNew-SmbShare -CimSession $newsession -Name $xname -Path \"C:\\ClusterStorage\\$xname\\share\" -FullAccess '域名\\domain admins','administrators'结论关键点在于这里，不能将SOF创建的volume直接作为共享目录，需要在这个volume上创建目录，然后针对目录操作就可以了。这有点类似于不能针对一个磁盘操作，但可以针对磁盘上的目录操作。" }, { "title": "Powershell整理文件夹", "url": "/PowerShell%E6%95%B4%E7%90%86%E6%96%87%E4%BB%B6%E5%A4%B9/", "categories": "", "tags": "", "date": "2019-09-24 00:00:00 +0800", "snippet": "背景最近被baidu盘提示说空间不足，想找一找哪些数据是不要的删除一下。但是baidu盘并没有提供特别快特别好用的全文搜索。所以我的想法是类似CMD一样，把baidu盘上的信息离线下来，然后慢慢分析PS C:\\&gt; tree C:.├───Intel│ ├───Logs│ └───Wireless│ └───Data├───PerfLogs├───Program Files│ ├───7-Zip│ │ └───Lang│ ├───ACD Systems│ │ └───ACDSee Ultimate│ │ └───10.0│ │ ├───1033│ │ ├───ACDSeeSR Themes│ │ │ ├───Black│ │ │ ├───blackshadow│ │ │ ├───green│ │ │ ├───grey│ │ │ ├───transparent│ │ │ ├───whiteshadow│ │ │ └───wood│ │ ├───AlbumGenerator│ │ │ └───Styles│ │ │ ├───Style1│ │ │ │ ├───cssBaiduPCSBaiduPCS是用GO语言写的，作者大哥的项目在这里 戳这里这是一个仿linux的cli工具，有了它，列目录这个事情才算有了最基础的平台。需求BaiduPCS也有tree命令，但是输出效果也是和cmd的tree一样，我需要的实际效果大概和下面类似 !3DS电影/ 3DS 电 影/ 3D 电 影/ 纪 录 片/ 日本风景名胜_400x240_1400kbps_30.303fps_2pass.moflex !3DS电影/ 3DS 电 影/ 3D 电 影/ 纪 录 片/ 宇宙的奥秘_400x240_1400kbps_23.976fps_2pass.moflex !3DS电影/ 3DS 电 影/ 3D 电 影/ 纪 录 片/ 拯救地球_400x240_1400kbps_29.964fps_2pass.moflex !3DS电影/ 3DS 电 影/ 3D 电 影/ 试 机 碟/ 月 光 1 &amp; 2/ 月 光 2_400x240_1400kbps_23.976fps_2pass.moflex !3DS电影/ 3DS 电 影/ 3D 电 影/ 试 机 碟/ 月 光 1 &amp; 2/ 月 光_400x240_1400kbps_23.976fps_2pass.moflex !3DS电影/ 3DS 电 影/ 3D 电 影/ 试 机 碟/ 月 光 3 &amp; 4/ 月 光 3_400x240_1400kbps_23.976fps_2pass.moflex !3DS电影/ 3DS 电 影/ 3D 电 影/ 试 机 碟/ 月 光 3 &amp; 4/ 月 光 4_400x240_1400kbps_24.000fps_2pass.moflex这样找到文件之后，我可以按照目录去baidu盘上删东西。实现实现代码如下#针对这个目标，主要是处理3种字符#├出现这个符号，则表示这一行有一个文件名，#如果这一行末位是/，则它是一个目录。否则，就是一个文件名#└出现这个符号，表示下一行，会换目录，比如当前是在一个3级目录，下次可能就是2级或者1级#│出现这个符号，表示这一行的数据处于某一个子目录下，出现一次就是1级目录#由于要将逻辑放在函数中，所以这里用到了全局变量。#为了输出更快，这里将数据放在ArrayList中，最后一次性输出。$aa = Get-Content C:\\333.txt$aa = $aa.replace(\"──\", \"\")#把正文中的横杠全删除掉，但是如果文件名中正好有这个字符，就同样会被处理掉$arrayx = New-Object System.Collections.ArrayList$global:pathname = \"\"函数主逻辑下面是关键部分，因为逻辑比较繁琐，写了注释。function sw ($x) { $x1 = $x[0] #检测每一行的第一个字符 #根目录逻辑，如果以├开头，且以/结尾，则表示它是一个根目录。这里全局变量就设置成├以后的部分 #。例如├── !3DS电影/ if ($x1 -eq '├' -and $x.EndsWith('/')) { $global:pathname = $x.Split('├')[-1] } #子目录逻辑，如果包含│，且以/结尾，则表示它是一个子目录。这里全局变量需要累加 #累加原值+“├”以后的部分 #例如│ │ ├── 3D 电 影/ if ($x1 -eq '│' -and $x.EndsWith('/') ) { $global:pathname = $pathname + $x.Split('├')[-1] } #子目录中的文件逻辑，如果包含│，且不以/结尾，则表示它是一个子目录的文件 if ($x1 -eq '│' -and ($x.EndsWith('/') -eq $false)) { #首先生成文件名，文件名的格式为全局变量的路径名称+“├或└”右侧的信息 $global:fname = $global:pathname + $x.Split('├')[-1].Split('└')[-1] #然后把数据吐到arraylist中，留到最后统一输出 $arrayx.add($global:fname) | out-null if ($x -match \"└\") { #如果路径中包含└，则需要进行处理，方便下一个待处理数据进行处理。例如如下两条是生成的记录 # #测试数据： #│ │ │ │ └── 无 敌 破 坏 王.2012_400x240_2000kbps_23.976fps_2pass.moflex #│ │ │ ├── 纪 录 片/ #│ │ │ │ ├── 风光/ #│ │ │ │ │ ├── 北碧_400x240_1400kbps_25.000fps_2pass.moflex # #以下是生成的数据： #!3DS电影/ 3DS 电 影/ 3D 电 影/ 电 影 v4/ 无 敌 破 坏 王.2012_400x240_2000kbps_23.976fps_2pass.moflex #!3DS电影/ 3DS 电 影/ 3D 电 影/ 纪 录 片/ 风光/ 北碧_400x240_1400kbps_25.000fps_2pass.moflex # #全局变量以/进行拆解，取0到 $x(未处理数据以│隔开)-3的位置，然后用/拼接回去，再加上/ #以上面举例，无敌破坏王是$x,当前全局变量是“!3DS电影/ 3DS 电 影/ 3D 电 影/ 电 影 v4/” #$x可以被拆分为5个部分，他在一个4级目录下 #全局变量以/拆解，可以被拆解为5个部分 #所以全局变量被拆解重新组合后，变成了0..(5-3),也就是到了上一级目录。 #而这种计算是自动的，所以可以做到从4级目录返回到3级，也可以从3级返回到1级。这里-3是上一级，-2是同级 #至于返回之后，下一条数据如果是目录，则依然可以返回 $global:pathname = ($global:pathname.Split('/')[0..(($x.split('│').count - 3) )] -join '/') + '/' } else { $global:pathname = ($global:pathname.Split('/')[0..($x.split('│').count - 2)] -join '/') + '/' } }}$aa | ForEach-Object { sw $_ }$arrayx | Out-File c:\\444.txt问题这里还有一个问题，就是如果是根目录，但是又是文件，应该如何处理。" }, { "title": "Powershell 文件名包含[]时，改后缀的方法", "url": "/PowerShell-%E6%96%87%E4%BB%B6%E5%90%8D%E5%8C%85%E5%90%AB-%E6%97%B6-%E6%94%B9%E5%90%8E%E7%BC%80%E7%9A%84%E6%96%B9%E6%B3%95/", "categories": "", "tags": "", "date": "2019-08-16 00:00:00 +0800", "snippet": "需求众所周知的问题，现在视频网站发布视频的方式方法已经有了很大的改变。比如mp4文件改名为mp41，类似下面这样PS E:\\BaiduNetdiskDownload&gt; ls *.mp41 -Recurse目?录?: E:\\BaiduNetdiskDownloadMode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2019/8/11 20:42 1322066936 [SUBPIG][Eien no Nispa SP].mp41然而实际按照[SUBPIG][Eien no Nispa SP].mp41这个文件名，用rename的方式去修改，却被提示失败。PS E:\\BaiduNetdiskDownload&gt; Rename-Computer \"[SUBPIG][Eien no Nispa SP].mp41\" \"[SUBPIG][Eien no Nispa SP].mp4\"Rename-Computer : 找不到接受实际参数“[SUBPIG][Eien no Nispa SP].mp4”的位置形式参数。所在位置 行:1 字符: 1+ Rename-Computer \"[SUBPIG][Eien no Nispa SP].mp41\" \"[SUBPIG][Eien no N ...+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : InvalidArgument: (:) [Rename-Computer]，ParameterBindingException + FullyQualifiedErrorId : PositionalParameterNotFound,Microsoft.PowerShell.Commands.RenameComputerCommand自动补齐这是为什么呢？其实原因很简单，因为PowerShell中，对于[]符号有特殊的定义，所以不能这么写。我们试试在命令行下直接运行它，系统会自动补齐什么样的字符转义PS E:\\BaiduNetdiskDownload&gt; &amp; '.\\[SUBPIG][Eien no Nispa SP].mp41'可以看到字符串前面有&amp; 然后跟一个空格，字符串被’ （单引号）包裹，这种方法可以用来运行一些包含了特殊字符的命令行工具，或者可执行程序，但是，在传递参数的时候还是用不了的。我们试试，在某一个参数中，指定路径或者文件名，看系统自动补齐会变成什么样子PS E:\\BaiduNetdiskDownload&gt; Rename-Item -Path '.\\`[SUBPIG`]`[Eien no Nispa SP`].mp41'大概这就是正确方式了吧，专门写了个函数function EscapeWord ($param1) { if ($param1 -match \"[[]\" -or $param1 -match \"[]]\") { $param1.replace('[', '`[').replace(']', '`]') }}EscapeWord \"E:\\BaiduNetdiskDownload\\[SUBPIG][FAKE AFFAIR EP05].mp41\"E:\\BaiduNetdiskDownload\\`[SUBPIG`]`[FAKE AFFAIR EP05`].mp41先单独一条数据执行下PS E:\\BaiduNetdiskDownload&gt; Rename-Item -Path '.\\`[SUBPIG`]`[Eien no Nispa SP`].mp41' -NewName '.\\`[SUBPIG`]`[Eien no Nispa SP`].mp4' Rename-Item : 指定路径 E:\\BaiduNetdiskDownload\\`[SUBPIG`]`[Eien no Nispa SP`].mp41 下的对象不存在。实际来看，还是失败了。变通解决实在是挺无语的，既然[]在PowerShell下被重新定义了，那CMD下总是好的吧。用CMD来混合一下。这次的做法是切割名称字符串，把最后一个字符串切掉，然后替换名称。依然可以达到需求，并且修改记录还会追加保存在一个文件中。(Get-ChildItem *.mp41 -Recurse) | ForEach-Object { $fullname = $_.fullname $fullname $NewName = $_.name $NewName = ($NewName[0..($NewName.Length - 2)] -join \"\") $NewName $info = \"rename `\"$fullname`\" `\"$NewName`\"\" cmd /c $info $info | Out-File c:\\333.txt -Append -Force -Encoding utf8}最终方案问题是解决了，但是实现方法太拧巴。如果有原生方法，上面的操作还是不会考虑的。我通过搜关键字 rename file PowerShell match []在东家找到了下面一个最终极的方案。https://answers.microsoft.com/en-us/windows/forum/windows_10-files/how-to-rename-image-files-in-a-folder-all-to-jpg/2a7e2873-e04b-472b-b239-afad2f2020fc果然解决不了的时候直接上.net都是一件利器。Get-ChildItem *.mp41 -Recurse | Rename-Item -newname { [io.path]::ChangeExtension($_.name, \"mp4\") }在https://stackoverflow.com/questions/5574648/use-regex-powershell-to-rename-files 也发现一个很有意思的替换方法，不过一样的，受限于[]，不太适合我的场景。Get-ChildItem *.mp41 | ForEach-Object{ Rename-Item $_ $(($_.name -replace '^filename_+','') -replace '_+',' ') }剩下的问题其实到这里，还有一个坑，如果有一天，需要对包含[]的文件，替换文件名，应该如何做呢？完美解决感谢唐老师在微信上指点，在https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/rename-item?view=powershell-6找到了这么一个参数。可以对路径名称不进行转义。经过测试，完美解决-LiteralPathSpecifies a path to one or more locations. The value of LiteralPath is used exactly as it is typed. No characters are interpreted as wildcards. If the path includes escape characters, enclose it in single quotation marks. Single quotation marks tell PowerShell not to interpret any characters as escape sequences.。PS E:\\BaiduNetdiskDownload&gt; $a =Get-ChildItem *.mp41 -RecursePS E:\\BaiduNetdiskDownload&gt; Rename-Item -LiteralPath $a.FullName -NewName \"[SUBPIG][FAKE AFFAIR EP05].mp4\"" } ]
